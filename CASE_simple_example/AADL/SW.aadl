package SW
public
	
	with Data_Model;
	with Base_Types;
	with claim;

	with CASE;
	
	with TB_SYS;


	-- This is the structure to hold the lat/long/alt values of a coordinate
	data Coordinate
	end Coordinate;
	
	data implementation Coordinate.Impl
		subcomponents
			lat : data Base_Types::Integer_32;
			longitude : data Base_Types::Integer_32;
			alt : data Base_Types::Integer_32;
	end Coordinate.Impl;
	
	-- The Map is a structure that contains a list of coordinates that encircle a
	-- region.  
	-- In this implementation, we fix the size of the map to 4 waypoints
	data Map
	end Map;
	
	data implementation Map.Impl
		subcomponents
			wp1 : data Coordinate.Impl;
			wp2 : data Coordinate.Impl;
			wp3 : data Coordinate.Impl;
			wp4 : data Coordinate.Impl;
	end Map.Impl;
	
	-- The Flight Pattern is an enumeration that defines how the UAV will fly through the
	-- sensing region to conduct surveillance.
	data FlightPattern
		--properties		
		--	Data_Model::Data_Representation => Enum;
		--	Data_Model::Enumerators => ("ZigZag", "StraightLine", "Perimeter");
	end FlightPattern;
	
	data implementation FlightPattern.Impl
		subcomponents
			enumAsInt : data Base_Types::Integer_32;
	end FlightPattern.Impl;
	
	-- The Command structure contains data that the Ground Station passes to the UAV.
	-- It contains a Map, Flight Pattern and Authentication bit.
	data Command
	end Command;
	
	data implementation Command.Impl
		subcomponents
			Map : data Map.Impl;
			Pattern: data FlightPattern.Impl;
			HMAC: data Base_Types::Boolean;
	end Command.Impl;
	
	-- The Mission is a list of waypoints that is generated by the Flight Planner based on a
	-- Map and Flight Pattern.
	-- For this implementation, we fix the size of the Mission to 10 waypoints.
	data Mission
	end Mission;
	
	data implementation Mission.Impl
		subcomponents
			wp1 : data Coordinate.Impl;
			wp2 : data Coordinate.Impl;
			wp3 : data Coordinate.Impl;
			wp4 : data Coordinate.Impl;
			wp5 : data Coordinate.Impl;
			wp6 : data Coordinate.Impl;
			wp7 : data Coordinate.Impl;
			wp8 : data Coordinate.Impl;
			wp9 : data Coordinate.Impl;
			wp10 : data Coordinate.Impl;
	end Mission.Impl;
	
	-- The Mission Window is a list of waypoints that the Waypoint Manager assembles from
	-- the Mission.
	-- For this implementation, we fix the size of the Mission Window to 4 waypoints.
	-- The crc value is an abstraction, which, if true, tells us that the data has not
	-- been corrupted.
	data MissionWindow
	end MissionWindow;
	
	data implementation MissionWindow.Impl
		subcomponents
			wp1 : data Coordinate.Impl;
			wp2 : data Coordinate.Impl;
			wp3 : data Coordinate.Impl;
			wp4 : data Coordinate.Impl;
			crc : data Base_Types::Boolean;
	end MissionWindow.Impl;
	
	
	thread RadioDriver
		features
			recv_map_in: in event data port Command.Impl;
			send_status_out: out event data port Coordinate.Impl;
			send_status_in: in event data port Coordinate.Impl;
			recv_map_out: out event data port Command.Impl;
		flows
			comm_map : flow path recv_map_in -> recv_map_out;
			comm_status : flow path send_status_in -> send_status_out;
    
    properties
      Dispatch_Protocol => Sporadic;
      Priority => 200;
      Stack_Size => 1024 Bytes;
      Compute_Execution_Time => 10 us .. 100 us;
      Period => 1 ms;
      TB_SYS::Sends_Events_To => "{{}}";
      			
		annex agree {**
			assume "Authenticated command from the Ground Station" : recv_map_in.HMAC = True;
			guarantee "Authenticated command from the Ground Station" : recv_map_out.HMAC = True;
		**};
		annex EMV2{**
			use types UAS_Errors;
			error propagations
				recv_map_in : in propagation {wellformed_authenticated, 
					wellformed_unauthenticated, not_wellformed_authenticated, not_wellformed_unauthenticated
				};
				recv_map_out : out propagation {wellformed_authenticated, not_wellformed_authenticated};
			flows
				authenticated_wellformed : error path recv_map_in{wellformed_authenticated} -> recv_map_out{wellformed_authenticated};
				authenticated_notwellformed : error path recv_map_in{not_wellformed_authenticated} -> recv_map_out{not_wellformed_authenticated};
				unauthenticated_map : error sink recv_map_in{not_wellformed_unauthenticated, wellformed_unauthenticated};
				
			end propagations;
		**};
	end RadioDriver;
	
	
	thread Filter
		features
			filter_in: in event data port Command.Impl;
			filter_out: out event data port Command.Impl;
		flows 
			filtered_cmd : flow path filter_in -> filter_out;
		properties
			CASE::COMP_TYPE => FILTER;
			CASE::COMP_IMPL => "CAKEML";
			CASE::COMP_SPEC => "(\\i{-90,90}\\i{-180,180}\\i{0,15000}){4}(Z|S|P)(T|F)";

      Dispatch_Protocol => Sporadic;
      Priority => 200;
      Stack_Size => 1024 Bytes;
      Compute_Execution_Time => 10 us .. 100 us;
      Period => 1 ms;
      TB_SYS::Sends_Events_To => "{{}}";			
--		annex agree {**
--			guarantee "The Flight Planner shall receive an authenticated command from the Ground Station" : filter_out.HMAC = True;
--			guarantee "The Flight Planner shall receive a well-formed command from the Ground Station" : SW.good_gs_command(filter_out);
--		**};
		annex EMV2{**
			use types UAS_Errors;
			error propagations
				filter_in : in propagation {wellformed_authenticated, not_wellformed_authenticated};
				filter_out : out propagation {wellformed_authenticated};
			flows
				
				wellformed_map : error path filter_in{wellformed_authenticated} -> filter_out{wellformed_authenticated};
				not_wellformed_map : error sink filter_in{not_wellformed_authenticated};
				
			end propagations;
		**};
			
	end Filter;
	
	
	thread FlightPlanner
		features
			flight_plan: out data port Mission.Impl;
			recv_map: in event data port Command.Impl;
			position_status: in event data port Coordinate.Impl;
		flows
			compute_flight_plan_map: flow path recv_map -> flight_plan;
			compute_flight_plan_pos: flow path position_status -> flight_plan;
    properties
      Dispatch_Protocol => Sporadic;
      Priority => 200;
      Stack_Size => 1024 Bytes;
      Compute_Execution_Time => 10 us .. 100 us;
      Period => 1 ms;
      TB_SYS::Sends_Events_To => "{{}}";
--		annex agree {**
--			assume "The Flight Planner shall receive an authenticated command from the Ground Station" : recv_map.HMAC = True;
--			assume "The Flight Planner shall receive a well-formed command from the Ground Station" : SW.good_gs_command(recv_map);
--			guarantee "The Flight Planner shall generate a valid mission" : SW.good_mission(flight_plan);
--		**};
		
		annex Resolute {**
			prove (well_formed(this))
		**};
		annex EMV2{**
			use types UAS_Errors;
			error propagations
				recv_map : in propagation {wellformed_authenticated};
				flight_plan : out propagation {wellformed_authenticated};
			flows
				authenticated_wellformed : error path recv_map{wellformed_authenticated} -> flight_plan{wellformed_authenticated};
							
			end propagations;
		**};
			
	end FlightPlanner;
	

	thread WaypointManager
		features
			flight_plan: in data port Mission.Impl;
			waypoint: out event data port MissionWindow.Impl;
			position_status: in event data port Coordinate.Impl;
		flows
			compute_waypoint_flight_plan: flow path flight_plan -> waypoint;
			compute_waypoint_pos_status :flow path position_status -> waypoint;
    properties
      Programming_Properties::Source_Text => ("test.o");
    
      Dispatch_Protocol => Sporadic;
      Priority => 200;
      Stack_Size => 1024 Bytes;
      Compute_Execution_Time => 10 us .. 100 us;
      Period => 1 ms;
      TB_SYS::Sends_Events_To => "{{}}";  
--		annex agree {**
--			assume "The Waypoint Manager shall receive a well-formed mission" : SW.good_mission(flight_plan);
--			guarantee "The Waypoint Manager shall output a well-formed mission window." : SW.good_mission_window(waypoint);
--		**};
		annex EMV2{**
			use types UAS_Errors;
			error propagations
				flight_plan : in propagation {wellformed_authenticated};
				waypoint : out propagation {wellformed_authenticated};
			flows
				authenticated_wellformed : error path flight_plan{wellformed_authenticated} -> waypoint{wellformed_authenticated};

				
				
			end propagations;
		**};
	end WaypointManager;
	
	thread UARTDriver
		features
			position_status_in: in event data port Coordinate.Impl;
			waypoint_out: out event data port MissionWindow.Impl;
			position_status_out: out event data port Coordinate.Impl;
			waypoint_in: in event data port MissionWindow.Impl;
		flows 
			comm_waypoint : flow path waypoint_in -> waypoint_out;
			comm_status : flow path position_status_in -> position_status_out;			
		properties
      Dispatch_Protocol => Sporadic;
      Priority => 200;
      Stack_Size => 1024 Bytes;
      Compute_Execution_Time => 10 us .. 100 us;
      Period => 1 ms;
      TB_SYS::Sends_Events_To => "{{}}";  			
--		annex agree {**
--			assume "Well-formed mission window" : SW.good_mission_window(waypoint_in);
--			guarantee "A CRC shall be appended to the message to determine message correctness" : waypoint_out.crc = True;
--		**};
		annex EMV2{**
			use types UAS_Errors;
			error propagations
				waypoint_in : in propagation {wellformed_authenticated};
				waypoint_out : out propagation {wellformed_authenticated};
			flows
				authenticated_wellformed : error path waypoint_in{wellformed_authenticated} -> waypoint_out{wellformed_authenticated};

				
				
			end propagations;
		**};
			
	end UARTDriver;

	process MC_SW
		features
			recv_map: in event data port Command.Impl;
			send_status: out event data port Coordinate.Impl;
			waypoint: out event data port MissionWindow.Impl;
			position_status: in event data port Coordinate.Impl;
		flows
			compute_waypoint_flight_plan: flow path recv_map -> waypoint;
			compute_waypoint_pos_status :flow path position_status -> waypoint;
			compute_status : flow path position_status -> send_status;
		annex agree {**
			-- we abstract away the authentication and just assume the message has undergone authenticity verification
			assume "The Mission Computer shall only accept authenticated commands from the Ground Station" : recv_map.HMAC = True;
			guarantee "The Mission Computer shall output a valid mission window to the Flight Controller" : waypoint.crc = True;
		**};
		annex EMV2{**
			use types UAS_Errors;
			error propagations
				recv_map : in propagation {wellformed_authenticated, wellformed_unauthenticated, 
					not_wellformed_authenticated, not_wellformed_unauthenticated
				};
				waypoint : out propagation {wellformed_authenticated};
			flows
				unauthenticated_map : error sink recv_map{not_wellformed_unauthenticated, wellformed_unauthenticated};
				authenticated_wellformed : error path recv_map{wellformed_authenticated} -> waypoint{wellformed_authenticated};
				not_wellformed_map : error sink recv_map{not_wellformed_authenticated,not_wellformed_unauthenticated};
				
			end propagations;
		**};	
			
	end MC_SW;

	process implementation MC_SW.Impl
		subcomponents
			RADIO: thread RadioDriver;
			FLT: thread Filter;
			FPLN: thread FlightPlanner;
			WPM: thread WaypointManager;
			UART: thread UARTDriver;
		connections
			c1: port recv_map -> RADIO.recv_map_in;
			c2: port RADIO.send_status_out -> send_status;
			c3: port RADIO.recv_map_out -> FLT.filter_in;
			c4: port FLT.filter_out -> FPLN.recv_map;
			c5: port FPLN.flight_plan -> WPM.flight_plan;
			c6: port WPM.waypoint -> UART.waypoint_in;
			c7: port UART.position_status_out -> WPM.position_status;
			c8: port UART.position_status_out -> FPLN.position_status;
			c9: port UART.position_status_out -> RADIO.send_status_in;
			c10: port UART.waypoint_out -> waypoint;
			c11: port position_status -> UART.position_status_in;
			
	end MC_SW.Impl;
	
	
--	annex agree {**
--			
--		-- These functions check the well-formedness of message structures
--		fun good_coordinate(coord : SW::Coordinate.Impl) : bool =	coord.lat >= -90 and 
--																	coord.lat <= 90 and 
--																	coord.longitude >= -180 and 
--																	coord.longitude <= 180 and 
--																	coord.alt >= 0 and 
--																	coord.alt <= 15000;
--																	
--		fun good_map(map : SW::Map.Impl) : bool =	good_coordinate(map.wp1) and 
--													good_coordinate(map.wp2) and 
--													good_coordinate(map.wp3) and 
--													good_coordinate(map.wp4);
--													
--		fun good_pattern(pattern : SW::FlightPattern) : bool =	(pattern = enum(SW::FlightPattern, ZigZag)) or 
--																(pattern = enum(SW::FlightPattern, StraightLine)) or 
--																(pattern = enum(SW::FlightPattern, Perimeter));
--																
--		fun good_HMAC(hmac : bool) : bool = (hmac = True) or (hmac = False);
--		
--		fun good_gs_command(cmd : SW::Command.Impl) : bool =	good_map(cmd.Map) and 
--																good_pattern(cmd.Pattern) and 
--																good_HMAC(cmd.HMAC);
--																
--		fun good_mission(mission : SW::Mission.Impl) : bool =	good_coordinate(mission.wp1) and 
--																good_coordinate(mission.wp2) and 
--																good_coordinate(mission.wp3) and 
--																good_coordinate(mission.wp4) and 
--																good_coordinate(mission.wp5) and 
--																good_coordinate(mission.wp6) and 
--																good_coordinate(mission.wp7) and 
--																good_coordinate(mission.wp8) and 
--																good_coordinate(mission.wp9) and 
--																good_coordinate(mission.wp10);
--																
--		fun good_mission_window(win : SW::MissionWindow.Impl) : bool =	good_coordinate(win.wp1) and 
--																		good_coordinate(win.wp2) and 
--																		good_coordinate(win.wp3) and 
--																		good_coordinate(win.wp4);
--																										
--	**};


	
end SW;
