package SW
public
	with SecurityLevels;
	with Data_Model;
	with Base_Types;
	with claim;

	with CASE;
	
	--with TB_SYS;


	-- This is the structure to hold the lat/long/alt values of a coordinate
	data Coordinate
	end Coordinate;
	
	data implementation Coordinate.Impl
		subcomponents
			lat : data Base_Types::Integer_32;
			longitude : data Base_Types::Integer_32;
			alt : data Base_Types::Integer_32;
	end Coordinate.Impl;
	
	-- The Map is a structure that contains a list of coordinates that encircle a
	-- region.  
	-- In this implementation, we fix the size of the map to 4 waypoints
	data Map
	end Map;
	
	data implementation Map.Impl
		subcomponents
			wp1 : data Coordinate.Impl;
			wp2 : data Coordinate.Impl;
			wp3 : data Coordinate.Impl;
			wp4 : data Coordinate.Impl;
	end Map.Impl;
	
	-- The Flight Pattern is an enumeration that defines how the UAV will fly through the
	-- sensing region to conduct surveillance.
	data FlightPattern
		properties		
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("ZigZag", "StraightLine", "Perimeter");
	end FlightPattern;
	
	data implementation FlightPattern.Impl
		subcomponents
			enumAsInt : data Base_Types::Integer_32;
	end FlightPattern.Impl;
	
	-- The Command structure contains data that the Ground Station passes to the UAV.
	-- It contains a Map, Flight Pattern and Authentication bit.
	data Command
	end Command;
	
	data implementation Command.Impl
		subcomponents
			Map : data Map.Impl;
			Pattern: data FlightPattern.Impl;
			HMAC: data Base_Types::Boolean;
			annex InfoFlow {**
				total domain Authenticity {
					authenticated: type;
					not_authenticated: type;	
				}
				total domain WellFormedness{
					wellformed: type refinement "Agree" good_gs_command(this);
					not_wellformed: type refinement "Agree" !good_gs_command(this);
				}
				invariant "wellformed messages are authenticated" :
					if(WellFormedness = wellformed) then Authenticity = authenticated;
			**};
	end Command.Impl;
	
	data wellformedness
		properties		
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("wellformed", "not_wellformed");
	end wellformedness;
	
	data implementation wellformedness.Impl
		subcomponents
			enumAsInt : data Base_Types::Integer_32;
	end wellformedness.Impl;
	
	data validity
		properties		
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("valid_flight_plan", "invalid_flight_plan", "safe_flight_plan");
	end validity;
	
	data implementation validity.Impl
		subcomponents
			enumAsInt : data Base_Types::Integer_32;
	end validity.Impl;
	
	-- The Mission is a list of waypoints that is generated by the Flight Planner based on a
	-- Map and Flight Pattern.
	-- For this implementation, we fix the size of the Mission to 10 waypoints.
	data Mission
	end Mission;
	
	data implementation Mission.Impl
		subcomponents
			wp1 : data Coordinate.Impl;
			wp2 : data Coordinate.Impl;
			wp3 : data Coordinate.Impl;
			wp4 : data Coordinate.Impl;
			wp5 : data Coordinate.Impl;
			wp6 : data Coordinate.Impl;
			wp7 : data Coordinate.Impl;
			wp8 : data Coordinate.Impl;
			wp9 : data Coordinate.Impl;
			wp10 : data Coordinate.Impl;
			wellness_prop : data wellformedness;
			validity_prop : data validity;
	end Mission.Impl;
	
	-- The Mission Window is a list of waypoints that the Waypoint Manager assembles from
	-- the Mission.
	-- For this implementation, we fix the size of the Mission Window to 4 waypoints.
	-- The crc value is an abstraction, which, if true, tells us that the data has not
	-- been corrupted.
	data MissionWindow
	end MissionWindow;
	
	data implementation MissionWindow.Impl
		subcomponents
			wp1 : data Coordinate.Impl;
			wp2 : data Coordinate.Impl;
			wp3 : data Coordinate.Impl;
			wp4 : data Coordinate.Impl;
			crc : data Base_Types::Boolean;
			wellness_prop : data wellformedness;
			validity_prop : data validity;
	end MissionWindow.Impl;
	
	
	thread RadioDriver
		features
			recv_map_in: in event data port Command.Impl;
			send_status_out: out event data port Coordinate.Impl;
			send_status_in: in event data port Coordinate.Impl;
			recv_map_out: out event data port Command.Impl;
		flows
			comm_map : flow path recv_map_in -> recv_map_out;
			comm_status : flow path send_status_in -> send_status_out;
			
		annex InfoFlow{**
			guarantee 
				"Authenticated command from the Ground Station" : recv_map_out.Authenticity = authenticated;
		**};
		
		
    
--    properties
--      Dispatch_Protocol => Sporadic;
--      Priority => 200;
--      Stack_Size => 1024 Bytes;
--      Compute_Execution_Time => 10 us .. 100 us;
--      Period => 1 ms;
--      TB_SYS::Sends_Events_To => "{{}}";
--      			
--		annex agree {**
--			assume "Authenticated command from the Ground Station" : recv_map_in.HMAC = True;
--			guarantee "Authenticated command from the Ground Station" : recv_map_out.HMAC = True;
--		**};
		annex EMV2{**
			use types UAS_Errors;
			error propagations
				recv_map_in : in propagation {wellformed_authenticated, 
					wellformed_unauthenticated, not_wellformed_authenticated, not_wellformed_unauthenticated
				};
				recv_map_out : out propagation {wellformed_authenticated, not_wellformed_authenticated};
			flows
				authenticated_wellformed : error path recv_map_in{wellformed_authenticated} -> recv_map_out{wellformed_authenticated};
				authenticated_notwellformed : error path recv_map_in{not_wellformed_authenticated} -> recv_map_out{not_wellformed_authenticated};
				unauthenticated_map : error sink recv_map_in{not_wellformed_unauthenticated, wellformed_unauthenticated};
				
			end propagations;
		**};
	end RadioDriver;
	
	
	thread Filter
		features
			filter_in: in event data port Command.Impl;
			filter_out: out event data port Command.Impl;
		flows 
			filtered_cmd : flow path filter_in -> filter_out;
		annex InfoFlow{**
			assume "Filter shall reecive an authenticated command from the Ground Station" : 
				filter_in.Authenticity = authenticated;
			guarantee "The Flight Planner shall receive a well-formed command from the Ground Station" : 
				filter_out.WellFormedness = wellformed;
			preserve
				filtered_cmd : {Authenticity}
		**};
		
		annex smf {**
			classification 
				filter_in : untrusted;
				filter_out : trusted;	
			de-classification
				filtered_cmd: untrusted -> trusted;
				
				
		**};	
--		properties
--			CASE::COMP_TYPE => FILTER;
--			CASE::COMP_IMPL => "CAKEML";
--			CASE::COMP_SPEC => "(\\i{-90,90}\\i{-180,180}\\i{0,15000}){4}(Z|S|P)(T|F)";
--
--      Dispatch_Protocol => Sporadic;
--      Priority => 200;
--      Stack_Size => 1024 Bytes;
--      Compute_Execution_Time => 10 us .. 100 us;
--      Period => 1 ms;
--      TB_SYS::Sends_Events_To => "{{}}";			
--		annex agree {**
--			guarantee "The Flight Planner shall receive an authenticated command from the Ground Station" : filter_out.HMAC = True;
--			guarantee "The Flight Planner shall receive a well-formed command from the Ground Station" : SW.good_gs_command(filter_out);
--		**};
		annex EMV2{**
			use types UAS_Errors;
			error propagations
				filter_in : in propagation {wellformed_authenticated, not_wellformed_authenticated};
				filter_out : out propagation {wellformed_authenticated};
			flows
				
				wellformed_map : error path filter_in{wellformed_authenticated} -> filter_out{wellformed_authenticated};
				not_wellformed_map : error sink filter_in{not_wellformed_authenticated};
				
			end propagations;
		**};
			
	end Filter;
	
	
	thread FlightPlanner
		features
			flight_plan: out data port Mission.Impl;
			recv_map: in event data port Command.Impl;
			position_status: in event data port Coordinate.Impl;
		flows
			compute_flight_plan_map: flow path recv_map -> flight_plan;
			compute_flight_plan_pos: flow path position_status -> flight_plan;
    properties
      Dispatch_Protocol => Sporadic;
      Priority => 200;
      Stack_Size => 1024 Bytes;
      Compute_Execution_Time => 10 us .. 100 us;
      Period => 1 ms;
      --TB_SYS::Sends_Events_To => "{{}}";
--		annex agree {**
--			assume "The Flight Planner shall receive an authenticated command from the Ground Station" : recv_map.HMAC = True;
--			assume "The Flight Planner shall receive a well-formed command from the Ground Station" : SW.good_gs_command(recv_map);
--			guarantee "The Flight Planner shall generate a valid mission" : SW.good_mission(flight_plan);
--		**};
--		annex InfoFlow{**
--			ensure 
--				flight_plan = flight_plan_domain;
--		**};
		
--		annex Resolute {**
--			prove (well_formed(this))
--		**};
		annex EMV2{**
			use types UAS_Errors;
			error propagations
				recv_map : in propagation {wellformed_authenticated};
				flight_plan : out propagation {wellformed_authenticated};
			flows
				authenticated_wellformed : error path recv_map{wellformed_authenticated} -> flight_plan{wellformed_authenticated};
							
			end propagations;
		**};
			
	end FlightPlanner;
	
	--instrumented components for threat 10
	thread flight_plan_fliter
		features
			flight_plan_in : in data port Mission.Impl;
			flight_plan_out : out data port Mission.Impl;
		flows
			flight_plan_wellformed: flow path flight_plan_in -> flight_plan_out;
			flight_plan_notwellformed: flow sink flight_plan_in;
		annex InfoFlow {**
			assume "Waypoints from flight planner shall be wellformed or not_wellformed" : 
				flight_plan_in:wellformedness = InfoFlow::wellformedness.wellformed or InfoFlow::wellformedness.not_wellformed;
			
			guarantee "flight_plan_fliter shall allow only wellformed waypoints":
				if(flight_plan_in:wellformedness = InfoFlow::wellformedness.wellformed) 
				then
					flight_plan_out:wellformedness = flight_plan_in:wellformedness and -- preserves wellformedness
					flight_plan_out:validity = InfoFlow::validity.Invalid_flight_plan or InfoFlow::validity.Valid_flight_plan; 
				else 
					flight_plan_out:validity = InfoFlow::validity.Invalid_flight_plan;
	
		**};	
		annex agree {**
			assume "Waypoints from flight planner shall be wellformed or not_wellformed" : flight_plan_in.wellness_prop =  enum(SW::wellformedness,wellformed) or flight_plan_in.wellness_prop = enum(SW::wellformedness,not_wellformed);
			guarantee "flight_plan_fliter shall allow only wellformed waypoints":  if (flight_plan_in.wellness_prop = enum(SW::wellformedness,wellformed)) then flight_plan_out.validity_prop = enum(SW::validity,valid_flight_plan) or flight_plan_out.validity_prop = enum(SW::validity,invalid_flight_plan) else flight_plan_out.validity_prop = enum(SW::validity,invalid_flight_plan);
		**};
	end flight_plan_fliter;
	
	thread flight_plan_validator
		features
			flight_plan_in : in data port Mission.Impl;
			flight_plan_out : out data port Mission.Impl;
		flows
			flight_plan_valid: flow path flight_plan_in -> flight_plan_out;	
			flight_plan_invalid: flow sink flight_plan_in;
		annex InfoFlow {**
			assume "Waypoints from flight planner shall be valid_flight_plan or invalid_flight_plan" :
				flight_plan_in:validity = InfoFlow::validity.Invalid_flight_plan or flight_plan_in:validity = InfoFlow::validity.Valid_flight_plan;
				
			guarantee  "invalid flight plans shall not reach waypoint manager":
				if(flight_plan_in:validity = InfoFlow::validity.Valid_flight_plan)
				then 
					flight_plan_out:validity = flight_plan_in:validity and flight_plan_out:wellformedness = flight_plan_in:wellformedness;
				else
					flight_plan_out:validity = InfoFlow::validity.Safe_flight_plan and flight_plan_out:wellformedness = flight_plan_in:wellformedness;
		**};
		annex agree {** 
			assume "Waypoints from flight planner shall be valid_flight_plan or invalid_flight_plan" : flight_plan_in.validity_prop =  enum(SW::validity,valid_flight_plan) or flight_plan_in.validity_prop =enum(SW::validity,invalid_flight_plan);
			guarantee "invalid flight plans shall not reach waypoint manager": if flight_plan_in.validity_prop =  enum(SW::validity,valid_flight_plan) then flight_plan_out.validity_prop = enum(SW::validity,valid_flight_plan) else flight_plan_out.validity_prop = enum(SW::validity,safe_flight_plan);
		**};
	end flight_plan_validator;
  	-- end of instrumented components for threat 10
  
	thread WaypointManager
		features
			flight_plan: in data port Mission.Impl;
			waypoint: out event data port MissionWindow.Impl;
			position_status: in event data port Coordinate.Impl;
		flows
			compute_waypoint_flight_plan: flow path flight_plan -> waypoint;
			compute_waypoint_pos_status :flow path position_status -> waypoint;
    properties
      Programming_Properties::Source_Text => ("test.o");
    
      Dispatch_Protocol => Sporadic;
      Priority => 200;
      Stack_Size => 1024 Bytes;
      Compute_Execution_Time => 10 us .. 100 us;
      Period => 1 ms;
    --  TB_SYS::Sends_Events_To => "{{}}";  
--		annex agree {**
--			assume "The Waypoint Manager shall receive a well-formed mission" : SW.good_mission(flight_plan);
--			guarantee "The Waypoint Manager shall output a well-formed mission window." : SW.good_mission_window(waypoint);
--		**};
		annex InfoFlow {**
			assume "The Waypoint Manager shall receive a valid mission" :
				(flight_plan:validity = InfoFlow::validity.Safe_flight_plan or flight_plan:validity = InfoFlow::validity.Valid_flight_plan) and
				(flight_plan:wellformedness = InfoFlow.wellformedness.wellformed);
		
			guarantee "waypoint manager shall generate wellformed and valid missions":
				waypoint:wellformedness = flight_plan.wellformedness and waypoint.validity = flight_plan.validity
				
		**};
		annex agree {**
			assume "The Waypoint Manager shall receive a valid mission" : flight_plan.validity_prop = enum(SW::validity,valid_flight_plan) or flight_plan.validity_prop = enum(SW::validity,safe_flight_plan);
			guarantee "waypoint manager shall generate wellformed and valid missions": waypoint.wellness_prop = flight_plan.wellness_prop and waypoint.validity_prop = flight_plan.validity_prop;
		**};
		annex EMV2{**
			use types UAS_Errors;
			error propagations
				flight_plan : in propagation {wellformed_authenticated};
				waypoint : out propagation {wellformed_authenticated};
			flows
				authenticated_wellformed : error path flight_plan{wellformed_authenticated} -> waypoint{wellformed_authenticated};
			end propagations;
		**};
	end WaypointManager;
	
	thread UARTDriver
		features
			position_status_in: in event data port Coordinate.Impl;
			waypoint_out: out event data port MissionWindow.Impl;
			position_status_out: out event data port Coordinate.Impl;
			waypoint_in: in event data port MissionWindow.Impl;
		flows 
			comm_waypoint : flow path waypoint_in -> waypoint_out;
			comm_status : flow path position_status_in -> position_status_out;			
		properties
      Dispatch_Protocol => Sporadic;
      Priority => 200;
      Stack_Size => 1024 Bytes;
      Compute_Execution_Time => 10 us .. 100 us;
      Period => 1 ms;
   --   TB_SYS::Sends_Events_To => "{{}}";  			
--		annex agree {**
--			assume "Well-formed mission window" : SW.good_mission_window(waypoint_in);
--			guarantee "A CRC shall be appended to the message to determine message correctness" : waypoint_out.crc = True;
--		**};
		annex agree {**
			assume "UARTDriver shall receive a valid mission window" :  waypoint_in.validity_prop = enum(SW::validity,valid_flight_plan) or waypoint_in.validity_prop = enum(SW::validity,safe_flight_plan);
			guarantee "UARTDriver shall generate a valid mission window" : waypoint_out = waypoint_in; 
		**};
		annex EMV2{**
			use types UAS_Errors;
			error propagations
				waypoint_in : in propagation {wellformed_authenticated};
				waypoint_out : out propagation {wellformed_authenticated};
			flows
				authenticated_wellformed : error path waypoint_in{wellformed_authenticated} -> waypoint_out{wellformed_authenticated};

				
				
			end propagations;
		**};
			
	end UARTDriver;

	process MC_SW
		features
			recv_map: in event data port Command.Impl;
			send_status: out event data port Coordinate.Impl;
			waypoint: out event data port MissionWindow.Impl;
			position_status: in event data port Coordinate.Impl;
		flows
			compute_waypoint_flight_plan: flow path recv_map -> waypoint;
			compute_waypoint_pos_status :flow path position_status -> waypoint;
			compute_status : flow path position_status -> send_status;
--		annex agree {**
--			-- we abstract away the authentication and just assume the message has undergone authenticity verification
--			assume "The Mission Computer shall only accept authenticated commands from the Ground Station" : recv_map.HMAC = True;
--			guarantee "The Mission Computer shall output a valid mission window to the Flight Controller" : waypoint.crc = True;
--		**};
		annex InfoFlow {**
			guarantee "The Mission Computer shall output a valid mission window to the Flight Controller" :
				waypoint:wellformedness = InfoFlow::wellformedness.wellformed and 
				(waypoint:validity = InfoFlow::validity.Safe_flight_plan or waypoint:validity = InfoFlow::validity.Valid_flight_plan)
		**};
		annex agree {**
			guarantee "The Mission Computer shall output a valid mission window to the Flight Controller" :waypoint.validity_prop = enum(SW::validity,valid_flight_plan) or waypoint.validity_prop =  enum(SW::validity,safe_flight_plan);
		**};
		annex EMV2{**
			use types UAS_Errors;
			error propagations
				recv_map : in propagation {wellformed_authenticated, wellformed_unauthenticated, 
					not_wellformed_authenticated, not_wellformed_unauthenticated
				};
				waypoint : out propagation {wellformed_authenticated};
			flows
				unauthenticated_map : error sink recv_map{not_wellformed_unauthenticated, wellformed_unauthenticated};
				authenticated_wellformed : error path recv_map{wellformed_authenticated} -> waypoint{wellformed_authenticated};
				not_wellformed_map : error sink recv_map{not_wellformed_authenticated,not_wellformed_unauthenticated};
				
			end propagations;
		**};	
			
	end MC_SW;

	process implementation MC_SW.Impl
		subcomponents
			RADIO: thread RadioDriver;
			FLT: thread Filter;
			FPLN_FLT: thread flight_plan_fliter;
			FPLN_VALID: thread flight_plan_validator;
			FPLN: thread FlightPlanner;
			WPM: thread WaypointManager;
			UART: thread UARTDriver;
		connections
			c1: port recv_map -> RADIO.recv_map_in;
			c2: port RADIO.send_status_out -> send_status;
			c3: port RADIO.recv_map_out -> FLT.filter_in;
			c4: port FLT.filter_out -> FPLN.recv_map;
			--c5: port FPLN.flight_plan -> WPM.flight_plan;
			c5_a: port FPLN.flight_plan -> FPLN_FLT.flight_plan_in; 
			c5_b: port  FPLN_FLT.flight_plan_out -> FPLN_VALID.flight_plan_in; 
			c5: port FPLN_VALID.flight_plan_out -> WPM.flight_plan;
			
			c6: port WPM.waypoint -> UART.waypoint_in;
			c7: port UART.position_status_out -> WPM.position_status;
			c8: port UART.position_status_out -> FPLN.position_status;
			c9: port UART.position_status_out -> RADIO.send_status_in;
			c10: port UART.waypoint_out -> waypoint;
			c11: port position_status -> UART.position_status_in;
			
--		annex InfoFlow {**
--			partitions
--				--untrusted
--				FPLN in trust_domain.Untrusted;
--				
--				--trusted
--				FPLN_FLT in trust_domain.trusted;
--				FPLN_VALID in trust_domain.trusted;
--				WPM in trust_domain.trusted;
--			assert
--			-- we have to say that all info flow from untrusted to trusted must go through filter 
--			-- in the flow path everything to the lhs of FPLN_FLT in untrusted and everything to rhs in trusted domain
--			-- There are no flow from untrusted to trusted even through the shared platform(processor) 
--				-- we have to somehow inform Awas/Anai to processor as non cross channel communication 
--				trust_domain.Untrusted -[FPLN_FLT]-> trust_domain.trusted;
--		**};	
	end MC_SW.Impl;
	
	
	annex agree {**
			
		-- These functions check the well-formedness of message structures
--		fun good_coordinate(coord : SW::Coordinate.Impl) : bool =	coord.lat >= -90 and 
--																	coord.lat <= 90 and 
--											
--																	coord.longitude >= -180 and 
--																	coord.longitude <= 180 and 
--																	coord.alt >= 0 and 
--																	coord.alt <= 15000;
--																	
--		fun good_map(map : SW::Map.Impl) : bool =	good_coordinate(map.wp1) and 
--													good_coordinate(map.wp2) and 
--													good_coordinate(map.wp3) and 
--													good_coordinate(map.wp4);
--													
--		fun good_pattern(pattern : SW::FlightPattern) : bool =	(pattern = enum(SW::FlightPattern, ZigZag)) or 
--																(pattern = enum(SW::FlightPattern, StraightLine)) or 
--																(pattern = enum(SW::FlightPattern, Perimeter));
--																
--		fun good_HMAC(hmac : bool) : bool = (hmac = True) or (hmac = False);
--		
--		fun good_gs_command(cmd : SW::Command.Impl) : bool =	good_map(cmd.Map) and 
--																good_pattern(cmd.Pattern) and 
--																good_HMAC(cmd.HMAC);
--																
--		fun good_mission(mission : SW::Mission.Impl) : bool =	good_coordinate(mission.wp1) and 
--																good_coordinate(mission.wp2) and 
--																good_coordinate(mission.wp3) and 
--																good_coordinate(mission.wp4) and 
--																good_coordinate(mission.wp5) and 
--																good_coordinate(mission.wp6) and 
--																good_coordinate(mission.wp7) and 
--																good_coordinate(mission.wp8) and 
--																good_coordinate(mission.wp9) and 
--																good_coordinate(mission.wp10);
--																
--		fun good_mission_window(win : SW::MissionWindow.Impl) : bool =	good_coordinate(win.wp1) and 
--																		good_coordinate(win.wp2) and 
--																		good_coordinate(win.wp3) and 
--																		good_coordinate(win.wp4);
--																										
--	**};


	
end SW;
