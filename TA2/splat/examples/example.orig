(*---------------------------------------------------------------------------*)
(* Towards an automated prover showing that a set of strings denoted by a    *)
(* regexp meets a specified higher level property.                           *)
(*
 * CAN ID Name Position (Format) Range of Values Units (Result)
 * Identifier 1800 
 * Time Day Byte 0 (unsigned char) 1 ... 31 
 * Time Month Byte 1 ( unsigned char) 1 ... 12 
 * Time Year Byte 2 ( unsigned char) 0 ... 99 
 * Time Hour Byte 3 ( unsigned char) 0 … 23 
 * Time Minute Byte 4 ( unsigned char) 0 … 59 
 * Time Second Byte 5 ( unsigned char) 0 … 59 
 * Altitude Byte 6, 7 (LSB, MSB) 0 … 17999 "m" (1 m)
 *
 * Identifier 1801 
 * Latitude Degrees Byte 0 (Bit 0 ...7) -90 ... +90 "Deg" (1°)
 * Latitude Minutes Byte 1 (Bit 8 ... 13) 0 ... 59 "Min" (1’)
 * Latitude Seconds Byte 2, 3 (Bit 16 ... 28) 0 ... 5999 "Sec" (0.01“)
 * Longitude Degrees Byte 4 (Bit 32 ... 40) -180 ... +180 "Deg" (1°)
 * Longitude Minutes Byte 5 (Bit 41 ... 46) 0 ... 59 "Min" (1’)
 * Longitude Seconds Byte 6, 7 (Bit 48 ... 60) 0 ... 5999 "Sec" (0.01“)
 * 
 * Identifier 1802 
 * Speed Byte 0, 1 (LSB, MSB) 0 ... 9999 "km/h" (0.1 km/h)
 * Heading Byte 2, 3 (LSB, MSB) 0 ... 3599 "Deg" (0.1°)
 * 
 *---------------------------------------------------------------------------*)

load "intLib";
load "regexpLib";
load "ASCIInumbersLib";
use "charset.sml";

(*---------------------------------------------------------------------------*)
(* Maps between num and string. Only one endian-ness dealt with right now.   *)
(*---------------------------------------------------------------------------*)

open arithmeticTheory listTheory stringTheory 
     charsetTheory FormalLangTheory regexpTheory 
     ASCIInumbersTheory numposrepTheory;

val _ = numLib.prefer_num();

infix byA;
val op byA = BasicProvers.byA;

val qpat_k_assum = Lib.C qpat_x_assum kall_tac;

fun qspec q th = th |> Q.SPEC q 
fun qspec_arith q th = qspec q th |> SIMP_RULE arith_ss [];

val var_eq_tac = rpt BasicProvers.VAR_EQ_TAC;

val decide = bossLib.DECIDE;
val qdecide = decide o Parse.Term;


val upto_def =
  tDefine 
   "upto" 
   `upto b t = if b > t then [] else b::upto (b+1n) t`
   (WF_REL_TAC `measure (\(b,t). t+1 - b)`);
					

val layout_def =  (* LSB with padding to width *)
 Define
  `layout b n width = PAD_RIGHT 0n width (n2l b n)`;

(*
EVAL ``layout 256 5999 2``;
EVAL ``layout 256 125 4``;
EVAL ``layout 256 0 4``;
*)

val enc_def = Define `enc w n = MAP CHR (layout 256 n w)`;
val dec_def = Define `dec s = l2n 256 (MAP ORD s)`;

val width_def = 
 Define 
  `width n = if n = 0 then 1 else SUC (LOG 256 n)`;

val n2l_256 =
 n2l_def 
  |> Q.SPECL [`n`,`256`] 
  |> SIMP_RULE arith_ss []
  |> Q.GEN `n`
;

val MAP_ORD_CHR = Q.prove
(`!list. EVERY ($> 256) list ==> (MAP (ORD o CHR) list = list)`,
 Induct >> rw_tac list_ss [ORD_CHR_RWT]);

val every_genlist_lem = Q.prove
(`!n c. EVERY ($= c) (GENLIST (K c) n)`,
 Induct >> rw_tac list_ss [GENLIST,EVERY_SNOC]);

val const_list_lem = Q.prove
(`!list c. EVERY ($= c) list ==> (c::list = list ++ [c])`,
 Induct 
 >> rw_tac list_ss [] 
 >> metis_tac []);

val const_reverse_lem = Q.prove
(`!list x. EVERY ($= x) list ==> (REVERSE list = list)`,
 Induct 
 >> rw_tac list_ss [] 
 >> metis_tac [const_list_lem]);

val reverse_const_genlist = Q.prove
(`!n c. REVERSE (GENLIST (K c) n) = GENLIST (K c) n`,
Induct 
 >> rw_tac list_ss [GENLIST,REVERSE_SNOC]
 >> rw_tac list_ss [SNOC_APPEND]
 >> metis_tac [every_genlist_lem,const_list_lem])

val l2n_append_zeros = Q.prove
(`!n list. l2n 256 (list ++ GENLIST (K 0) n) = l2n 256 list`,
Induct 
 >> rw_tac list_ss [GENLIST]
 >> metis_tac [APPEND_SNOC, qspec_arith `256` l2n_SNOC_0]);

val dec_enc = Q.prove
(`!n w. dec (enc w n) = n`,
 rw_tac list_ss [enc_def, dec_def,layout_def,MAP_MAP_o]
 >> `EVERY ($> 256) (PAD_RIGHT 0 w (n2l 256 n))`
     by (rw_tac list_ss [PAD_RIGHT]
         >- metis_tac [n2l_BOUND |> Q.SPEC `256` |> SIMP_RULE arith_ss []]
         >- rw_tac list_ss [EVERY_GENLIST])
 >> rw_tac list_ss [MAP_ORD_CHR]
 >> pop_assum kall_tac
 >> rw_tac list_ss [PAD_RIGHT,l2n_append_zeros]
 >> metis_tac [l2n_n2l,DECIDE ``1n < 256``]);

EVAL ``MAP (dec o enc 2) (upto 0 1024) = upto 0 1024``;

(*---------------------------------------------------------------------------*)
(* Simple example                                                            *)
(*---------------------------------------------------------------------------*)

Hol_datatype
   `dms = <| degrees : num ;   (* avoid ints for now *)
             minutes : num ; 
             seconds : num |>`;

val good_dms_def =
  Define
    `good_dms recd <=>
         0 <= recd.degrees /\ recd.degrees <= 90 /\
         0 <= recd.minutes /\ recd.minutes <= 59 /\
         0 <= recd.seconds /\ recd.seconds <= 5999`;

map Interval.interval_byte_width [ (0,90), (0,59), (0,5999)];

val enc_degrees_def =
    Define `enc_degrees d = enc 1 d`;

val enc_minutes_def =
    Define `enc_minutes m = enc 1 m`;

val enc_seconds_def =
    Define `enc_seconds s = enc 2 s`;

val enc_dms_def =
    Define
    `enc_dms recd =
       CONCAT [enc_degrees recd.degrees;
               enc_minutes recd.minutes;
               enc_seconds recd.seconds]`;

val dec_dms_def =
 Define 
  `dec_dms s =
    case s 
     of [dch; mch; sch1; sch2] => 
        SOME <| degrees := dec [dch]; 
                minutes := dec [mch]; 
                seconds := dec [sch1; sch2] |>
      | otherwise => NONE`;
	     
Count.apply EVAL ``enc_dms <|degrees := 14; minutes := 35; seconds := 1440|>``;
Count.apply EVAL 
  ``dec_dms (enc_dms <|degrees := 14; minutes := 35; seconds := 1440|>)``;

val pad_right_n2l_lem = Q.prove
(`!n m c. PAD_RIGHT c 1 (n2l 256 n) = [m] <=> (n2l 256 n = [m])`,
 ONCE_REWRITE_TAC [n2l_def]
 >> rw_tac list_ss [PAD_RIGHT,EQ_IMP_THM]);

val dec_enc_dms = Q.prove
(`!m. good_dms m ==> (dec_dms (enc_dms m) = SOME m)`,
 rw_tac list_ss [good_dms_def,dec_dms_def, enc_dms_def,
                 enc_degrees_def, enc_minutes_def, enc_seconds_def]
  >> `(?a. enc 1 m.degrees = STRING a "") /\
      (?b. enc 1 m.minutes = STRING b "") /\
      (?c d. enc 2 m.seconds = STRING c (STRING d ""))`
      by (rw_tac list_ss [enc_def,layout_def,pad_right_n2l_lem]
          >> rw_tac list_ss [Once n2l_256]
          >- rw_tac list_ss [PAD_RIGHT,GENLIST]
          >- (`m.seconds DIV 256 <= 5999 DIV 256`
	          by metis_tac[arithmeticTheory.DIV_LE_MONOTONE,DECIDE ``0 < 256``]
	       >> `m.seconds DIV 256 < 256` by full_simp_tac arith_ss []
               >> rw_tac list_ss [Once n2l_256]
	       >> rw_tac list_ss [PAD_RIGHT, GENLIST]))
  >> rw_tac list_ss [fetch "-" "dms_component_equality"]
  >> metis_tac [dec_enc])

val dms_regexp = Regexp_Type.fromQuote `\i{0,90}\i{0,59}\i{0,5999}`;

val dms_regexp_term = regexpSyntax.mk_regexp dms_regexp;

(*---------------------------------------------------------------------------*)
(* lift to level of msg format                                               *)
(*---------------------------------------------------------------------------*)

val ss = list_ss ++ charset_conv_ss;

val regexp_lang_cat = el 2 (CONJUNCTS regexp_lang_def);
val regexp_lang_or = last (CONJUNCTS regexp_lang_def);

val n2l_bytes_1 = Q.prove
(`!n. n < 256 ==> (n2l 256 n = [n])`,
 rw_tac list_ss [Once n2l_256]);

val n2l_bytes_2 = Q.prove
(`!n. ~(n < 256) /\ n < 65536 ==> 
       (n2l 256 n = [n MOD 256; (n DIV 256) MOD 256])`,
 rw_tac list_ss 
    [Ntimes n2l_256 2, 
     arithmeticTheory.DIV_DIV_DIV_MULT,arithmeticTheory.DIV_LT_X]);

val n2l_bytes_3 = Q.prove
(`!n. ~(n < 65536) /\ n < 256 * 65536 ==> 
       (n2l 256 n = [n MOD 256; 
                     (n DIV 256) MOD 256;
		     (n DIV 65536) MOD 256])`,
 rw_tac list_ss 
    [Ntimes n2l_256 3, 
     arithmeticTheory.DIV_DIV_DIV_MULT,arithmeticTheory.DIV_LT_X]);

val enc_1_lem = Q.prove
(`!n. n < 256 ==> (enc 1 n = STRING (CHR n) "")`,
 rw_tac list_ss [enc_def, PAD_RIGHT, GENLIST, layout_def,n2l_bytes_1]);


val enc_2_lem = Q.prove
(`!n. n < 256 * 256 ==> 
      (enc 2 n = STRING (CHR (n MOD 256)) 
                (STRING (CHR ((n DIV 256) MOD 256)) ""))`,
rw_tac list_ss [enc_def, PAD_RIGHT, GENLIST, layout_def,n2l_bytes_2]
 >> Cases_on `n < 256`
 >- rw_tac list_ss [n2l_bytes_1,arithmeticTheory.LESS_DIV_EQ_ZERO]
 >- rw_tac list_ss [n2l_bytes_2]);

val enc_3_lem = Q.prove
(`!n. n < 256 * 256 * 256 ==> 
      (enc 3 n = STRING (CHR (n MOD 256)) 
                (STRING (CHR ((n DIV 256) MOD 256)) 
                (STRING (CHR ((n DIV 65536) MOD 256)) "")))`,
rw_tac list_ss [enc_def, PAD_RIGHT, GENLIST, layout_def]
 >> Cases_on `n < 256`
 >- rw_tac list_ss [n2l_bytes_1,arithmeticTheory.LESS_DIV_EQ_ZERO]
 >- (Cases_on `n < 65536`
     >- rw_tac list_ss [n2l_bytes_2,arithmeticTheory.LESS_DIV_EQ_ZERO]
     >- rw_tac list_ss [n2l_bytes_3]));

val enc_2_pad = Q.prove
(`!n. n < 256 ==> (enc 2 n = STRING (CHR n) (STRING (CHR 0) ""))`,
rw_tac list_ss [enc_def, PAD_RIGHT, GENLIST, layout_def, Once n2l_256]
 >> rw_tac list_ss [Once n2l_256]);

val lower_length_n2l = Q.prove
(`!b n. 1 <= LENGTH (n2l b n)`,
rw_tac list_ss [Once n2l_def]);

val lower_enc_1 = Q.prove
(`!n. 1 <= LENGTH (enc 1 n)`,
rw_tac list_ss [enc_def,layout_def, PAD_RIGHT]);

val lower_enc_2 = Q.prove
(`!n. 2 <= LENGTH (enc 2 n)`,
rw_tac list_ss [enc_def,layout_def, PAD_RIGHT]);

val lem_len_1 = Q.prove
(`!n. n < 256 ==> (LENGTH (n2l 256 n) = 1)`,
 rw_tac list_ss [Once numposrepTheory.n2l_def]);

val lem_len_2 = Q.prove
(`!n. ~(n < 256) /\ n <= 5999 ==> (LENGTH (n2l 256 n) = 2)`,
 rw_tac arith_ss [qspec_arith `256` LENGTH_n2l]
 >> `0 < n` by decide_tac
 >> IMP_RES_TAC (qspec_arith `256` logrootTheory.LOG_LE_MONO)
 >> pop_assum (assume_tac o CONV_RULE (RAND_CONV EVAL))
 >> metis_tac [qspec_arith `256` logrootTheory.LOG_EQ_0,
               DECIDE ``a <=1 <=> (a=0) \/ (a=1)``]);

(* The charset_conv conversion can be sped up *)

val lemA = Q.prove
(`!n. n < 256 ==> STRING (CHR n) "" IN regexp_lang (Chset charset_full)`,
 CONV_TAC ((QUANT_CONV o RAND_CONV o RAND_CONV o RAND_CONV) EVAL)
  >> simp_tac ss [charset_full_def]
  >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
  >> rw_tac bool_ss []);

val lemB =
    lemA |> CONV_RULE ((QUANT_CONV o RAND_CONV o RAND_CONV o RAND_CONV) EVAL);

val STRLEN_EQ_1 = Q.prove
(`!s. (STRLEN s = 1) <=> ?c. s = STRING c ""`,
 Induct >> rw_tac list_ss []);

val LENGTH_PAD_RIGHT = Q.prove
(`!list c n. n <= LENGTH (PAD_RIGHT c n list)`,
 Induct >> rw_tac list_ss [PAD_RIGHT]);

val pos_len_n2l = Q.prove
(`!n. 0 < LENGTH (n2l 256 n)`, 
 rw_tac list_ss [Once n2l_def])

val n2l_sing = Q.prove
(`!b m n. (b = 256) /\ (n2l b m = [n]) ==> (m=n) /\ m < 256`, 
 recInduct n2l_ind 
  >> rw_tac list_ss [] 
  >> qpat_x_assum `n2l _ _ = _` mp_tac
  >> rw_tac list_ss [Once n2l_def]
  >- (pop_assum (mp_tac o Q.AP_TERM `LENGTH`)
      >> metis_tac [prim_recTheory.LESS_NOT_EQ,LENGTH,pos_len_n2l])
  >- (disj2_tac 
      >> disch_then (mp_tac o Q.AP_TERM `LENGTH`)
      >> metis_tac [prim_recTheory.LESS_NOT_EQ,LENGTH,pos_len_n2l]));

val ord_lem = Q.prove
(`!c. ORD c MOD 256 = ORD c`,
 gen_tac >> assume_tac (SPEC_ALL ORD_BOUND) >> rw_tac arith_ss []);

val map_chr_eq = Q.prove
(`!list s. EVERY ($> 256) list ==> ((MAP CHR list = s) <=> list = MAP ORD s)`,
Induct 
 >> rw_tac list_ss []
 >- metis_tac []
 >- (Cases_on `s`
     >> rw_tac list_ss [EQ_IMP_THM]
     >- rw_tac arith_ss [ORD_CHR_RWT]
     >- rw_tac arith_ss [CHR_ORD]));

val ilem1 = Q.prove
(`!s. (LENGTH s = 1) /\ dec s <= 90 ==> 
        s IN regexp_lang (Chset (Charset 0xFFFFFFFFFFFFFFFFw 0x7FFFFFFw 0w 0w))`,
 Cases 
 >> rw_tac list_ss [dec_def,l2n_def,ord_lem]
 >> full_simp_tac list_ss [l2n_def,arithmeticTheory.LE_LT1]
 >> pop_assum mp_tac
 >> Q.ID_SPEC_TAC `h`
 >> ho_match_mp_tac stringTheory.CHAR_INDUCT_THM
 >> rw_tac list_ss [ORD_CHR_RWT]
 >> pop_assum mp_tac
 >> pop_assum kall_tac
 >> Q.ID_SPEC_TAC `n`
 >> simp_tac ss []
 >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
 >> metis_tac []);

val ilem1A = Q.prove
(`!s. (LENGTH s = 1) /\ dec s <= 90 
      <=> 
      s IN regexp_lang (Chset (Charset 0xFFFFFFFFFFFFFFFFw 0x7FFFFFFw 0w 0w))`,
  rw_tac ss [EQ_IMP_THM,dec_def,l2n_def]
  >> rw_tac list_ss [stringTheory.STRLEN_DEF,l2n_def,ORD_CHR_RWT]
  >- (Cases_on `s`
      >> full_simp_tac list_ss [l2n_def,ord_lem]
      >> var_eq_tac
      >> full_simp_tac list_ss [l2n_def]
      >> pop_assum mp_tac
      >> Q.ID_SPEC_TAC `h`
      >> ho_match_mp_tac stringTheory.CHAR_INDUCT_THM
      >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
      >> metis_tac []));

val ilem2 = Q.prove
(`!s. (LENGTH s = 1) /\ dec s <= 59 ==> 
      s IN regexp_lang (Chset (Charset 0xFFFFFFFFFFFFFFFw 0w 0w 0w))`,
 Cases 
 >> rw_tac list_ss [dec_def,l2n_def,ord_lem]
 >> full_simp_tac list_ss [l2n_def,arithmeticTheory.LE_LT1]
 >> pop_assum mp_tac
 >> Q.ID_SPEC_TAC `h`
 >> ho_match_mp_tac stringTheory.CHAR_INDUCT_THM
 >> rw_tac list_ss [ORD_CHR_RWT]
 >> pop_assum mp_tac
 >> pop_assum kall_tac
 >> Q.ID_SPEC_TAC `n`
 >> simp_tac ss []
 >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
 >> metis_tac []);

val ilem2A = Q.prove
(`!s. (LENGTH s = 1) /\ dec s <= 59 <=> 
      s IN regexp_lang (Chset (Charset 0xFFFFFFFFFFFFFFFw 0w 0w 0w))`,
  rw_tac ss [EQ_IMP_THM,dec_def,l2n_def]
  >> rw_tac list_ss [stringTheory.STRLEN_DEF,l2n_def,ORD_CHR_RWT]
  >- (Cases_on `s`
      >> full_simp_tac list_ss [l2n_def,ord_lem]
      >> var_eq_tac
      >> full_simp_tac list_ss [l2n_def]
      >> pop_assum mp_tac
      >> Q.ID_SPEC_TAC `h`
      >> ho_match_mp_tac stringTheory.CHAR_INDUCT_THM
      >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
      >> metis_tac []));


val ilem3 = Q.prove
(`!s. (LENGTH s = 1) /\ dec s < 256 ==> 
      s IN regexp_lang 
            (Chset 
              (Charset 0xFFFFFFFFFFFFFFFFw 
                       0xFFFFFFFFFFFFFFFFw 
                       0xFFFFFFFFFFFFFFFFw
                       0xFFFFFFFFFFFFFFFFw))`,
 Cases 
 >> rw_tac list_ss [dec_def,l2n_def,ord_lem]
 >> full_simp_tac list_ss [l2n_def]
 >> pop_assum mp_tac
 >> Q.ID_SPEC_TAC `h`
 >> ho_match_mp_tac stringTheory.CHAR_INDUCT_THM
 >> rw_tac list_ss [ORD_CHR_RWT]
 >> pop_assum mp_tac
 >> Q.ID_SPEC_TAC `n`
 >> simp_tac ss []
 >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
 >> metis_tac []);

val ilem3A = Q.prove
(`!s. (LENGTH s = 1) /\ dec s < 256 <=> 
      s IN regexp_lang 
            (Chset 
              (Charset 0xFFFFFFFFFFFFFFFFw 
                       0xFFFFFFFFFFFFFFFFw 
                       0xFFFFFFFFFFFFFFFFw
                       0xFFFFFFFFFFFFFFFFw))`,
  rw_tac ss [EQ_IMP_THM,dec_def,l2n_def]
  >> rw_tac list_ss [stringTheory.STRLEN_DEF,l2n_def,ORD_CHR_RWT]
  >- (Cases_on `s`
      >> full_simp_tac list_ss [l2n_def,ord_lem]
      >> var_eq_tac
      >> full_simp_tac list_ss [l2n_def]
      >> pop_assum mp_tac
      >> Q.ID_SPEC_TAC `h`
      >> ho_match_mp_tac stringTheory.CHAR_INDUCT_THM
      >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
      >> metis_tac []));

val ilem4 = Q.prove
(`!s. (LENGTH s = 1) /\ dec s < 23 ==> 
      s IN regexp_lang 
            (Chset 
              (Charset 0x7FFFFFw 0w 0w 0w))`,
 Cases 
 >> rw_tac list_ss [dec_def,l2n_def,ord_lem]
 >> full_simp_tac list_ss [l2n_def]
 >> pop_assum mp_tac
 >> Q.ID_SPEC_TAC `h`
 >> ho_match_mp_tac stringTheory.CHAR_INDUCT_THM
 >> rw_tac list_ss [ORD_CHR_RWT]
 >> pop_assum mp_tac
 >> Q.ID_SPEC_TAC `n`
 >> simp_tac ss []
 >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
 >> metis_tac []);

val ilem4A = Q.prove
(`!s. (LENGTH s = 1) /\ dec s < 23 <=> 
      s IN regexp_lang 
            (Chset 
              (Charset 0x7FFFFFw 0w 0w 0w))`,
  rw_tac ss [EQ_IMP_THM,dec_def,l2n_def]
  >> rw_tac list_ss [stringTheory.STRLEN_DEF,l2n_def,ORD_CHR_RWT]
  >- (Cases_on `s`
      >> full_simp_tac list_ss [l2n_def,ord_lem]
      >> var_eq_tac
      >> full_simp_tac list_ss [l2n_def]
      >> pop_assum mp_tac
      >> Q.ID_SPEC_TAC `h`
      >> ho_match_mp_tac stringTheory.CHAR_INDUCT_THM
      >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
      >> metis_tac []));

val ilem3B = Q.prove
(`!s. (LENGTH s = 2) /\ dec s < 5888 <=> 
      s IN regexp_lang 
             (Cat
                 (Chset
                    (Charset 0xFFFFFFFFFFFFFFFFw 0xFFFFFFFFFFFFFFFFw
                       0xFFFFFFFFFFFFFFFFw 0xFFFFFFFFFFFFFFFFw))
                 (Chset (Charset 0x7FFFFFw 0w 0w 0w)))`,
 rw_tac list_ss [regexp_lang_cat,IN_dot,GSYM ilem3A,GSYM ilem4A]
 >> rw_tac list_ss [EQ_IMP_THM]
 >- (Cases_on `s`
     >> TRY (Cases_on `t`)
     >> full_simp_tac list_ss []
     >> var_eq_tac
     >> full_simp_tac list_ss [dec_def,l2n_def,ord_lem]
     >> qexists_tac `STRING h ""`
     >> qexists_tac `STRING h' ""`
     >> rw_tac list_ss [l2n_def])
 >- rw_tac list_ss []
 >- (Cases_on `u` 
     >> Cases_on `v`
     >> rw_tac list_ss [dec_def]
     >> full_simp_tac list_ss []
     >> var_eq_tac
     >> full_simp_tac list_ss [dec_def,l2n_def,ord_lem]));

val ilem5 = Q.prove
(`!s. (LENGTH s = 1) /\ dec s < 112 ==> 
      s IN regexp_lang 
            (Chset 
              (Charset 0xFFFFFFFFFFFFFFFFw 0xFFFFFFFFFFFFw 0w 0w))`,
 Cases 
 >> rw_tac list_ss [dec_def,l2n_def,ord_lem]
 >> full_simp_tac list_ss [l2n_def]
 >> pop_assum mp_tac
 >> Q.ID_SPEC_TAC `h`
 >> ho_match_mp_tac stringTheory.CHAR_INDUCT_THM
 >> rw_tac list_ss [ORD_CHR_RWT]
 >> pop_assum mp_tac
 >> Q.ID_SPEC_TAC `n`
 >> simp_tac ss []
 >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
 >> metis_tac []);

val ilem5A = Q.prove
(`!s. (LENGTH s = 1) /\ dec s < 112 <=> 
      s IN regexp_lang 
            (Chset 
              (Charset 0xFFFFFFFFFFFFFFFFw 0xFFFFFFFFFFFFw 0w 0w))`,
  rw_tac ss [EQ_IMP_THM,dec_def,l2n_def]
  >> rw_tac list_ss [stringTheory.STRLEN_DEF,l2n_def,ORD_CHR_RWT]
  >- (Cases_on `s`
      >> full_simp_tac list_ss [l2n_def,ord_lem]
      >> var_eq_tac
      >> full_simp_tac list_ss [l2n_def]
      >> pop_assum mp_tac
      >> Q.ID_SPEC_TAC `h`
      >> ho_match_mp_tac stringTheory.CHAR_INDUCT_THM
      >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
      >> metis_tac []));

val ilem6 = Q.prove
(`!s. (LENGTH s = 1) /\ (dec s = 23) ==> 
      s IN regexp_lang 
            (Chset 
              (Charset 0x800000w 0w 0w 0w))`,
 Cases 
 >> rw_tac list_ss [dec_def,l2n_def,ord_lem]
 >> full_simp_tac list_ss [l2n_def]
 >> pop_assum mp_tac
 >> Q.ID_SPEC_TAC `h`
 >> ho_match_mp_tac stringTheory.CHAR_INDUCT_THM
 >> rw_tac list_ss [ORD_CHR_RWT]
 >> pop_assum mp_tac
 >> Q.ID_SPEC_TAC `n`
 >> simp_tac ss []
 >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
 >> metis_tac []);

val ilem6A = Q.prove
(`!s. (LENGTH s = 1) /\ (dec s = 23) 
      <=> 
      s IN regexp_lang 
            (Chset 
              (Charset 0x800000w 0w 0w 0w))`,
  rw_tac ss [EQ_IMP_THM]
 >- (Cases_on `s` 
     >> full_simp_tac list_ss [dec_def,l2n_def]
     >> var_eq_tac
     >> full_simp_tac list_ss [l2n_def]
     >> pop_assum mp_tac  
     >> Q.ID_SPEC_TAC `h`
     >> ho_match_mp_tac stringTheory.CHAR_INDUCT_THM
     >> rw_tac list_ss [ORD_CHR_RWT])
 >- EVAL_TAC)
;

val ilem3C = Q.prove
(`!s. (LENGTH s = 2) /\ 5888 <= dec s /\ dec s < 6000 <=> 
      s IN regexp_lang 
            (Cat (Chset
                    (Charset 0xFFFFFFFFFFFFFFFFw 0xFFFFFFFFFFFFw 0w 0w))
                    (Chset (Charset 0x800000w 0w 0w 0w)))`,
 rw_tac list_ss [regexp_lang_cat,IN_dot,GSYM ilem5A,GSYM ilem6A,decide ``x:num < 6000 <=> x <= 5999``]
 >> rw_tac list_ss [EQ_IMP_THM]
 >- (Cases_on `s` >> TRY (Cases_on `t`)
     >> full_simp_tac list_ss []
     >> var_eq_tac
     >> qexists_tac `STRING h ""`
     >> qexists_tac `STRING h' ""`
     >> full_simp_tac list_ss [dec_def,l2n_def,ord_lem]
     >> `ORD h < 256 /\ ORD h' < 256` by metis_tac [ORD_BOUND]
     >> rw_tac list_ss [l2n_def,ord_lem]
     >> `ORD h' = 23` by decide_tac
     >> full_simp_tac arith_ss [])
 >- rw_tac list_ss []
 >- (Cases_on `u` 
     >> Cases_on `v`
     >> full_simp_tac list_ss [dec_def, l2n_def, ord_lem]
     >> var_eq_tac
     >> full_simp_tac list_ss [dec_def,l2n_def,ord_lem])
 >- (Cases_on `u` 
     >> Cases_on `v`
     >> full_simp_tac list_ss [dec_def, l2n_def, ord_lem]
     >> var_eq_tac
     >> full_simp_tac list_ss [dec_def,l2n_def,ord_lem])
);

(*
val interval_mod_lem = Q.prove
(`!b n f r.
     0 < b ==> f * b <= n /\ n <= f * b + r /\ r < b ==> n MOD b <= r`,
 rpt strip_tac
 >> qpat_x_assum `f*b <= n` 
      (strip_assume_tac o SIMP_RULE bool_ss [LESS_EQ_EXISTS])
 >> rw_tac arith_ss []
 >> full_simp_tac arith_ss []
 >> `p < b` by decide_tac
 >> rw_tac bool_ss [Once ADD_SYM, Once MULT_SYM]
 >> rw_tac bool_ss [MOD_MULT]);
*)

val list_len_lem = Q.prove
(`!L1 L2 L3 h1 h2 h3 h4. 
    1 <= LENGTH L1 /\ 1 <= LENGTH L2 /\ 2 <= LENGTH L3 /\
    (L1 ++ L2 ++ L3 = [h1;h2;h3;h4])
   ==>
    (L1 = [h1]) /\
    (L2 = [h2]) /\
    (L3 = [h3;h4])`,
 map_every Cases_on [`L1`, `L2`, `L3`]
  >> full_simp_tac list_ss [qdecide `2 <= SUC n <=> 0 < n`]
  >> Cases_on `t''` >> full_simp_tac list_ss []
  >> rpt gen_tac
  >> disch_then (fn th => assume_tac th >> assume_tac (Q.AP_TERM `LENGTH` th))
  >> Cases_on `t` >> full_simp_tac list_ss []
  >> Cases_on `t'` >> full_simp_tac list_ss []);

 
val AGREE_PROP = Q.prove
(`!m:dms. good_dms m <=> enc_dms(m) IN regexp_lang ^dms_regexp_term`,
 rw_tac list_ss [EQ_IMP_THM]
 >- (rw_tac (list_ss ++ pred_setLib.PRED_SET_ss) 
	   [regexp_lang_cat,regexp_lang_or,LIST_UNION_def,
            enc_dms_def, enc_degrees_def, enc_minutes_def, enc_seconds_def]
     >> full_simp_tac list_ss [good_dms_def]
     >> rw_tac bool_ss [Once (GSYM STRCAT_ASSOC)]
     >> rpt (match_mp_tac STRCAT_IN_dot ORELSE CONJ_TAC)
     >- rw_tac list_ss [GSYM ilem1A,dec_enc, enc_1_lem]
     >- rw_tac list_ss [GSYM ilem2A,dec_enc, enc_1_lem]
     >- (rw_tac list_ss [pred_setTheory.IN_UNION]
         >> pop_assum mp_tac >> rpt (pop_assum kall_tac) 
         >> qspec_tac (`m.seconds`, `secs`) >> rpt strip_tac
         >> rw_tac list_ss [GSYM regexp_lang_cat,GSYM ilem3B, GSYM ilem3C,dec_enc]
	 >> full_simp_tac bool_ss 
               [decide ``secs <= 5999n <=> 
                        secs < 23 * 256 \/ 
                        23 * 256 <= secs /\ secs <= 23 * 256 + 111``]
         >> rw_tac list_ss [enc_2_lem]))
 >- (full_simp_tac (list_ss ++ pred_setLib.PRED_SET_ss) 
	   [regexp_lang_cat,regexp_lang_or,LIST_UNION_def,
            enc_dms_def, enc_degrees_def, enc_minutes_def, enc_seconds_def]
     >> full_simp_tac bool_ss [Once (GSYM STRCAT_ASSOC)]
     >> full_simp_tac list_ss 
         [regexp_lang_or,regexp_lang_cat,regexpTheory.LIST_UNION_def,IN_dot,
	  GSYM ilem1A,GSYM ilem2A,GSYM ilem3A,GSYM ilem4A,GSYM ilem5A,GSYM ilem6A,
          GSYM ilem3B,GSYM ilem3C]
     >> Cases_on `u` >> Cases_on `u'` >> Cases_on `u''` >> Cases_on `v''` >> full_simp_tac list_ss []
     >> var_eq_tac
     >- (`1 <= LENGTH (enc 1 m.degrees) /\ 
          1 <= LENGTH (enc 1 m.minutes) /\
	  2 <= LENGTH (enc 2 m.seconds)` by metis_tac [lower_enc_1,lower_enc_2]
         >> drule (Q.ISPECL [`enc 1 m.degrees`, `enc 1 m.minutes`, `enc 2 m.seconds`] list_len_lem)
         >> rw_tac list_ss []
         >> full_simp_tac list_ss []
         >> `m.degrees <= 90` by metis_tac [dec_enc,good_dms_def]
         >> `m.minutes <= 59` by metis_tac [dec_enc,good_dms_def]
	 >> (`m.seconds = dec (STRING h'' (STRING h''' ""))` by metis_tac [dec_enc]
	     >> rw_tac list_ss []
             >> full_simp_tac list_ss [dec_def, l2n_def,ord_lem,good_dms_def]))
     >- (`1 <= LENGTH (enc 1 m.degrees) /\ 
          1 <= LENGTH (enc 1 m.minutes) /\
	  2 <= LENGTH (enc 2 m.seconds)` by metis_tac [lower_enc_1,lower_enc_2]
         >> drule (Q.ISPECL [`enc 1 m.degrees`, `enc 1 m.minutes`, `enc 2 m.seconds`] list_len_lem)
         >> rw_tac list_ss []
         >> full_simp_tac list_ss []
         >> `m.degrees <= 90` by metis_tac [dec_enc,good_dms_def]
         >> `m.minutes <= 59` by metis_tac [dec_enc,good_dms_def]
	 >> (`m.seconds = dec (STRING h'' (STRING h''' ""))` by metis_tac [dec_enc]
	     >> rw_tac list_ss []
             >> full_simp_tac list_ss [dec_def, l2n_def,ord_lem,good_dms_def]))));


(* original monster proof
rw_tac list_ss [EQ_IMP_THM]
 >- (rw_tac bool_ss [regexp_lang_cat]
     >> full_simp_tac arith_ss [good_dms_def]
     >> rw_tac bool_ss [enc_dms_def,listTheory.FLAT]
     >> rpt (match_mp_tac STRCAT_IN_dot ORELSE conj_tac)
     >- (qpat_x_assum `m.degrees <= 90` mp_tac
         >> ntac 2 (pop_assum kall_tac)
         >> qspec_tac (`m.degrees`, `d`)
	 >> simp_tac list_ss 
               [enc_degrees_def,dec_def, 
                arithmeticTheory.LE_LT1 Once numposrepTheory.n2l_def]
         >> simp_tac ss []
         >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
         >> rw_tac bool_ss [])
     >- (qpat_x_assum `m.minutes <= 59` mp_tac
	 >> ntac 2 (pop_assum kall_tac)
	 >> qspec_tac (`m.minutes`, `mins`)
         >> simp_tac list_ss 
              [enc_degrees_def,dec_def,
               arithmeticTheory.LE_LT1, Once numposrepTheory.n2l_def]
         >> simp_tac ss []
         >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
         >> rw_tac bool_ss [])
     >- (qpat_x_assum `m.seconds <= 5999` mp_tac
         >> ntac 2 (pop_assum kall_tac)
         >> qspec_tac (`m.seconds`, `secs`)
         >> rpt strip_tac
         >> rw_tac list_ss [enc_seconds_def,enc_def,layout_def,PAD_RIGHT,dec_def]
	 >> simp_tac list_ss [Once numposrepTheory.n2l_def]
	 >> rw_tac list_ss []
	 >- (`LENGTH (n2l 256 secs) = 1` by metis_tac [lem_len_1]
 	      >> pop_assum SUBST_ALL_TAC
              >> rw_tac list_ss []
	      >> rw_tac list_ss 
                   [regexp_lang_or,regexp_lang_cat,regexpTheory.LIST_UNION_def]
	      >> disj1_tac
              >> simp_tac list_ss [IN_dot]
              >> qexists_tac `STRING (CHR secs) ""` 
              >> qexists_tac `STRING (CHR 0) ""`
              >> rw_tac list_ss []
              >- metis_tac [lemB]
	      >- simp_tac ss [])
	 >- (`LENGTH (n2l 256 secs) = 2` by metis_tac [lem_len_2]
 	      >> pop_assum SUBST_ALL_TAC
              >> rw_tac list_ss []
              >> full_simp_tac bool_ss 
                   [DECIDE ``secs <= 5999n <=> secs < 23 * 256 \/ 
                                        23 * 256 <= secs /\ secs <= 23 * 256 + 111``]
	      >- (`secs DIV 256 <= 23 * 256 DIV 256`
                       by (match_mp_tac arithmeticTheory.DIV_LE_MONOTONE >> EVAL_TAC >> decide_tac)
                   >> `secs DIV 256 < 256` by full_simp_tac arith_ss []
                   >> rw_tac list_ss [Once numposrepTheory.n2l_def]
                   >> rw_tac list_ss [regexp_lang_or,regexp_lang_cat,regexpTheory.LIST_UNION_def]
	           >> disj1_tac
                   >> simp_tac list_ss [IN_dot]
                   >> qexists_tac `STRING (CHR (secs MOD 256)) ""` 
                   >> qexists_tac `STRING (CHR (secs DIV 256)) ""`
                   >> rw_tac list_ss []
                   >- (match_mp_tac lemB >> rw_tac arith_ss [])
                   >- (`secs <= 22 * 256 + 255` by decide_tac
                       >> pop_assum (fn th => mp_tac th >> rpt (pop_assum kall_tac) >> assume_tac th)
                       >> `secs DIV 256 <= (22 * 256 + 255) DIV 256`
                             by (match_mp_tac arithmeticTheory.DIV_LE_MONOTONE >> EVAL_TAC >> decide_tac)
                       >> full_simp_tac arith_ss []
                       >> full_simp_tac arith_ss [arithmeticTheory.LE_LT1]
                       >> qpat_x_assum `secs DIV 256 < 23` mp_tac
                       >> rpt (pop_assum kall_tac)
                       >> qspec_tac (`secs DIV 256`, `n`)
                       >> simp_tac ss []
                       >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
                       >> metis_tac[]))
	      >- (`secs DIV 256 = 23` by rw_tac arith_ss [arithmeticTheory.DIV_EQ_X]
                   >> rw_tac list_ss [Once numposrepTheory.n2l_def]
                   >> rw_tac list_ss [regexp_lang_or,regexp_lang_cat,regexpTheory.LIST_UNION_def]
	           >> disj2_tac
                   >> simp_tac list_ss [IN_dot]
                   >> qexists_tac `STRING (CHR (secs MOD 256)) ""` 
                   >> qexists_tac `STRING (CHR 23) ""`
                   >> rw_tac list_ss []
                   >- (`secs MOD 256 <= 111`
                          by (mp_tac (arithmeticTheory.DIVISION |> Q.SPEC `256` |> CONV_RULE EVAL |> Q.SPEC `secs`)
                              >> asm_simp_tac arith_ss [])
                        >> full_simp_tac arith_ss [arithmeticTheory.LE_LT1]
                       >> qpat_x_assum `secs MOD 256 < 112` mp_tac
                       >> rpt (pop_assum kall_tac)
                       >> qspec_tac (`secs MOD 256`, `n`)
                       >> simp_tac ss []
                       >> REPEAT (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
                       >> metis_tac[])
                   >- simp_tac ss []))))
 >- (full_simp_tac list_ss 
        [enc_dms_def,enc_degrees_def, enc_minutes_def, 
         enc_seconds_def,enc_def,layout_def]
     >> full_simp_tac list_ss 
         [regexp_lang_or,regexp_lang_cat,regexpTheory.LIST_UNION_def,IN_dot]
     >> rw_tac std_ss []
     >> full_simp_tac bool_ss [Once (GSYM STRCAT_ASSOC)]
     >- ( 
     val ([g1,g2,g3,g4,g5],_) = top_goal();

     val charset_lemA = Q.prove
     (`^g2 <=> (STRLEN u'' = 1) /\ dec u'' < 256`,
     Q.SPEC_TAC (`u''`, `s`)
      >> simp_tac ss []
      >> (rw_tac list_ss [EQ_IMP_THM] >> EVAL_TAC)
      >> (Cases_on `s` >> full_simp_tac list_ss [])
      >> pop_assum mp_tac
      >> pop_assum SUBST_ALL_TAC
      >> simp_tac list_ss [dec_def, l2n_def]
      >> Q.SPEC_TAC (`h`, `c`)
      >> ho_match_mp_tac CHAR_INDUCT_THM
      >> rpt (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
      >> metis_tac[]);

     >> full_simp_tac std_ss [charset_lemA]

     val charset_lemB = Q.prove
     (`^g1 <=> (STRLEN v'' = 1) /\ dec v'' < 23`,
     Q.SPEC_TAC (`v''`, `s`)
      >> simp_tac ss []
      >> (rw_tac list_ss [EQ_IMP_THM] >> EVAL_TAC)
      >> (Cases_on `s` >> full_simp_tac list_ss [])
      >> pop_assum mp_tac
      >> pop_assum SUBST_ALL_TAC
      >> simp_tac list_ss [dec_def, l2n_def]
      >> Q.SPEC_TAC (`h`, `c`)
      >> ho_match_mp_tac CHAR_INDUCT_THM
      >> rpt (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
      >> metis_tac[]);

     >> full_simp_tac std_ss [charset_lemB]

     val charset_lemC = Q.prove
     (`^g3 <=> (STRLEN u' = 1) /\ dec u' < 60`,
     Q.SPEC_TAC (`u'`, `s`)
      >> simp_tac ss []
      >> (rw_tac list_ss [EQ_IMP_THM] >> EVAL_TAC)
      >> (Cases_on `s` >> full_simp_tac list_ss [])
      >> pop_assum mp_tac
      >> pop_assum SUBST_ALL_TAC
      >> simp_tac list_ss [dec_def, l2n_def]
      >> Q.SPEC_TAC (`h`, `c`)
      >> ho_match_mp_tac CHAR_INDUCT_THM
      >> rpt (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
      >> metis_tac[]);

     val charset_lemD = Q.prove
     (`^g4 <=> (STRLEN u = 1) /\ dec u < 91`,
     Q.SPEC_TAC (`u`, `s`)
      >> simp_tac ss []
      >> (rw_tac list_ss [EQ_IMP_THM] >> EVAL_TAC)
      >> (Cases_on `s` >> full_simp_tac list_ss [])
      >> pop_assum mp_tac
      >> pop_assum SUBST_ALL_TAC
      >> simp_tac list_ss [dec_def, l2n_def]
      >> Q.SPEC_TAC (`h`, `c`)
      >> ho_match_mp_tac CHAR_INDUCT_THM
      >> rpt (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
      >> metis_tac[]);

     >> full_simp_tac std_ss [charset_lemC,charset_lemD,STRLEN_EQ_1]
     >> rw_tac list_ss []
     >> full_simp_tac list_ss []	
     >> `1 <= LENGTH (MAP CHR (PAD_RIGHT 0 1 (n2l 256 m.degrees))) /\
         1 <= LENGTH (MAP CHR (PAD_RIGHT 0 1 (n2l 256 m.minutes))) /\
         2 <= LENGTH (MAP CHR (PAD_RIGHT 0 2 (n2l 256 m.seconds)))`
            by metis_tac [LENGTH_PAD_RIGHT,LENGTH_MAP]
     >> `(?h1 t1. MAP CHR (PAD_RIGHT 0 1 (n2l 256 m.degrees)) = h1::t1)`
              by (Cases_on `MAP CHR (PAD_RIGHT 0 1 (n2l 256 m.degrees))`
                  >> full_simp_tac list_ss [])
     >> `(?h2 t2. MAP CHR (PAD_RIGHT 0 1 (n2l 256 m.minutes)) = h2::t2)`
               by (Cases_on `MAP CHR (PAD_RIGHT 0 1 (n2l 256 m.minutes))`
                    >> full_simp_tac list_ss [])
     >> `(?h3 h4 t3. MAP CHR (PAD_RIGHT 0 2 (n2l 256 m.seconds)) = h3::h4::t3)`
              by (Cases_on `MAP CHR (PAD_RIGHT 0 2 (n2l 256 m.seconds))`
                  >> full_simp_tac list_ss []
                  >> Cases_on `t` >> full_simp_tac list_ss [])
     >> `(t1 = []) /\ (t2 = []) /\ (t3 = [])` 
          by (CCONTR_TAC 
	      >> full_simp_tac bool_ss [] 
	      >- (`?ht1 tt1. t1 = ht1::tt1` by metis_tac [list_CASES] 
                   >> qpat_x_assum `STRCAT L1 L2 = STRING c rst` (mp_tac o Q.AP_TERM `STRLEN`)
		   >> rw_tac list_ss [])
	      >- (`?ht2 tt2. t2 = ht2::tt2` by metis_tac [list_CASES] 
                   >> qpat_x_assum `STRCAT L1 L2 = STRING c rst` (mp_tac o Q.AP_TERM `STRLEN`)
		   >> rw_tac list_ss [])
	      >- (`?ht3 tt3. t3 = ht3::tt3` by metis_tac [list_CASES] 
                   >> qpat_x_assum `STRCAT L1 L2 = STRING c rst` (mp_tac o Q.AP_TERM `STRLEN`)
		   >> rw_tac list_ss []))
     >> rw_tac list_ss []
     >> full_simp_tac list_ss []
     >> rw_tac list_ss []
     >> full_simp_tac list_ss []
     >> rw_tac list_ss []
     >> full_simp_tac list_ss [pad_right_n2l_lem]
     >> rw_tac list_ss [good_dms_def]
     >- (`(x0 = m.degrees) /\ x0 < 256` by metis_tac [n2l_sing]
         >> full_simp_tac list_ss [dec_def,ORD_CHR_RWT,l2n_def])
     >- (`(x0' = m.minutes) /\ x0' < 256` by metis_tac [n2l_sing]
         >> full_simp_tac list_ss [dec_def,ORD_CHR_RWT,l2n_def])
     >- (qpat_k_assum `_ < 91` 
         >> qpat_k_assum `_ < 60`
         >> ntac 2 (qpat_k_assum `n2l 256 _ = _`)
         >> full_simp_tac list_ss [GSYM (SIMP_RULE std_ss [layout_def] enc_def)]
         >> pop_assum (mp_tac o Q.AP_TERM `dec`)
         >> rw_tac list_ss [dec_enc]
         >> ntac 2 (pop_assum kall_tac)
         >> full_simp_tac list_ss [dec_def,l2n_def]
	 >> pop_assum mp_tac
         >> WEAKEN_TAC (K true)
         >> Q.SPEC_TAC (`ORD c''' MOD 256`, `n`)
         >> `ORD c'' MOD 256 < 256` by simp_tac arith_ss []
	 >> pop_assum mp_tac
	 >> Q.SPEC_TAC (`ORD c'' MOD 256`, `m`)
         >> decide_tac))
   >- (full_simp_tac std_ss [charset_lemC,charset_lemD,STRLEN_EQ_1]
       >> rw_tac list_ss []
     val ([g1,g2,g3,g4,g5],_) = top_goal();

     val charset_lemE = Q.prove
     (`^g1 <=> (STRLEN v'' = 1) /\ dec v'' = 23`,
     Q.SPEC_TAC (`v''`, `s`)
      >> simp_tac ss []
      >> (rw_tac list_ss [EQ_IMP_THM] >> EVAL_TAC)
      >> (Cases_on `s` >> full_simp_tac list_ss [])
      >> rw_tac list_ss []
      >> pop_assum mp_tac
      >> simp_tac list_ss [dec_def, l2n_def,ord_lem]
      >> strip_tac
      >> rw_tac list_ss [Once (GSYM ORD_11)]
      >> EVAL_TAC);

     >> full_simp_tac std_ss [charset_lemE]

     val charset_lemF = Q.prove
     (`^g2 <=> (STRLEN u'' = 1) /\ dec u'' < 112`,
     Q.SPEC_TAC (`u''`, `s`)
      >> simp_tac ss []
      >> (rw_tac list_ss [EQ_IMP_THM] >> EVAL_TAC)
      >> (Cases_on `s` >> full_simp_tac list_ss [])
      >> rw_tac list_ss []
      >> pop_assum mp_tac
      >> simp_tac list_ss [dec_def, l2n_def,ord_lem]
      >> Q.ID_SPEC_TAC `h`
      >> ho_match_mp_tac CHAR_INDUCT_THM
      >> rpt (CONV_TAC (numLib.BOUNDED_FORALL_CONV EVAL))
      >> metis_tac[]);

     >> full_simp_tac std_ss [charset_lemF,STRLEN_EQ_1]
     >> rw_tac list_ss []

     >> `1 <= LENGTH (MAP CHR (PAD_RIGHT 0 1 (n2l 256 m.degrees))) /\
         1 <= LENGTH (MAP CHR (PAD_RIGHT 0 1 (n2l 256 m.minutes))) /\
         2 <= LENGTH (MAP CHR (PAD_RIGHT 0 2 (n2l 256 m.seconds)))`
            by metis_tac [LENGTH_PAD_RIGHT,LENGTH_MAP]
     >> `(?h1 t1. MAP CHR (PAD_RIGHT 0 1 (n2l 256 m.degrees)) = h1::t1)`
              by (Cases_on `MAP CHR (PAD_RIGHT 0 1 (n2l 256 m.degrees))`
                  >> full_simp_tac list_ss [])
     >> `(?h2 t2. MAP CHR (PAD_RIGHT 0 1 (n2l 256 m.minutes)) = h2::t2)`
               by (Cases_on `MAP CHR (PAD_RIGHT 0 1 (n2l 256 m.minutes))`
                    >> full_simp_tac list_ss [])
     >> `(?h3 h4 t3. MAP CHR (PAD_RIGHT 0 2 (n2l 256 m.seconds)) = h3::h4::t3)`
              by (Cases_on `MAP CHR (PAD_RIGHT 0 2 (n2l 256 m.seconds))`
                  >> full_simp_tac list_ss []
                  >> Cases_on `t` >> full_simp_tac list_ss [])
     >> `(t1 = []) /\ (t2 = []) /\ (t3 = [])` 
          by (CCONTR_TAC 
	      >> full_simp_tac list_ss [] 
	      >- (`?ht1 tt1. t1 = ht1::tt1` by metis_tac [list_CASES] 
                   >> qpat_x_assum `STRCAT _ _ = STRING _ _` (mp_tac o Q.AP_TERM `STRLEN`)
		   >> rw_tac list_ss [])
	      >- (`?ht2 tt2. t2 = ht2::tt2` by metis_tac [list_CASES] 
                   >> qpat_x_assum `STRCAT _ _ = STRING _ _` (mp_tac o Q.AP_TERM `STRLEN`)
		   >> rw_tac list_ss [])
	      >- (`?ht3 tt3. t3 = ht3::tt3` by metis_tac [list_CASES] 
                   >> qpat_x_assum `STRCAT _ _ = STRING _ _` (mp_tac o Q.AP_TERM `STRLEN`)
		   >> rw_tac list_ss []))
     >> rw_tac list_ss []
     >> full_simp_tac list_ss []
     >> rw_tac list_ss []
     >> full_simp_tac list_ss []
     >> rw_tac list_ss []
     >> full_simp_tac list_ss [pad_right_n2l_lem,GSYM (enc_def |> SIMP_RULE std_ss [layout_def])]
     >> rw_tac list_ss [good_dms_def]
     >- (`(x0 = m.degrees) /\ x0 < 256` by metis_tac [n2l_sing]
         >> full_simp_tac list_ss [dec_def,ORD_CHR_RWT,l2n_def])
     >- (`(x0' = m.minutes) /\ x0' < 256` by metis_tac [n2l_sing]
         >> full_simp_tac list_ss [dec_def,ORD_CHR_RWT,l2n_def])
     >- (qpat_k_assum `_ < 91` 
         >> qpat_k_assum `_ < 60`
         >> ntac 2 (qpat_k_assum `n2l 256 _ = _`)
         >> qpat_x_assum `2 <= _` kall_tac
         >> pop_assum (mp_tac o Q.AP_TERM `dec`)
         >> rw_tac list_ss [dec_enc]
         >> full_simp_tac list_ss [dec_def,l2n_def]))
    )
*)


(* TODO 
val num_string_inv = store_thm
("num_string_inv",
  ``!n. toNum (toString n) = n``,
  STRIP_TAC THEN
  SRW_TAC [][string_from_num_def, num_from_string_def] THEN
  MATCH_MP_TAC s2n_n2s THEN SIMP_TAC (srw_ss()) []);

val num_to_string_inj = store_thm
("num_to_string_inj",
   ``!n m. (toString n = toString m) = (n = m)``,
   METIS_TAC [num_string_inv]);

val STRCAT_toString_inj = store_thm
("STRCAT_num_to_string_inj",
   ``!n m s. (STRCAT s (toString n) = STRCAT s (toString m)) = (n = m)``,
   SRW_TAC [] [num_to_string_inj]);
*)

(*
val NumFromAsciiString_def = Define`
   NumFromAsciiString s =
      if s <> "" then
         SOME (num_from_string s)
      else NONE`;
*)


(*---------------------------------------------------------------------------*)
(* Need string -> int map as well                                            *)
(*---------------------------------------------------------------------------*)

(*
val int_from_string_def = Define `int_from_string s = ARB:int`;
val string_from_int_def = Define `string_from_int i = ARB:string`;

val _ = overload_on ("toString", ``string_from_int``);
val _ = overload_on ("toInt", ``int_from_string``);

(*
val IntFromAsciiString_def = Define`
   IntFromAsciiString s =
      if s <> "" then
         SOME (int_from_string s)
      else NONE`;
*)


(*---------------------------------------------------------------------------*)
(* Example: gps coordinates                                                  *)
(*---------------------------------------------------------------------------*)

Hol_datatype
   `dms = <| degrees : int ; 
             minutes : num ; 
             seconds : num |>`;

val degrees_to_string_def =
    Define `degrees_to_string d = string_from_int i`;

val minutes_to_string_def =
    Define `minutes_to_string m = string_from_num m`;

val seconds_to_string_def =
    Define `seconds_to_string s = string_from_num s`;

val dms_to_string_def =
    Define
    `dms_to_string dms =
       CONCAT [degrees_to_string dms.degrees;
               minutes_to_string dms.minutes;
               seconds_to_string dms.seconds]`;

Hol_datatype (* latitude, longitude, altitude *)
  `gps = <| lat : dms;
            lon : dms; 
            alt : int |>`;

val alt_to_string_def =
    Define
     `alt_to_string a = int_to_string a`;

val good_gps_def =
  Define
    `good_gps recd =
       ~90 <= recd.lat.degrees /\ recd.lat.degrees <= 90 /\
         0 <= recd.lat.minutes /\ recd.lat.minutes <= 59 /\
         0 <= recd.lat.seconds /\ recd.lat.seconds <= 5999 
      /\
      ~180 <= recd.lon.degrees /\ recd.lon.degrees <= 180 /\
         0 <= recd.lon.minutes /\ recd.lon.minutes <= 59 /\
         0 <= recd.lon.seconds /\ recd.lon.seconds <= 5999 
      /\
         0 <= recd.alt /\ recd.alt <= 17999i`;


val gps_to_string_def =
    Define
     `gps_to_string gps =
       CONCAT [dms_to_string gps.lat;
               dms_to_string gps.lon;
               alt_to_string gps.alt]`;

(*---------------------------------------------------------------------------*)
(* Message type                                                              *)
(*---------------------------------------------------------------------------*)

Hol_datatype
  `msg = <| coord : gps; 
            traversal : char; 
            authenticated : char |>`;

val good_msg_def =
 Define
   `good_msg m <=> 
      good_gps m.coord /\
      m.traversal IN { #"L" ; #"G" ; #"S"} /\
      m.authenticated IN { #"T" ; #"F"}`;

val char_to_string_def =
 Define
  `char_to_string ch = STRING ch EMPTYSTRING`;

val msg_to_string_def =
    Define
     `msg_to_string msg =
	    CONCAT
		[gps_to_string msg.coord;
		 char_to_string msg.traversal;
		 char_to_string msg.authenticated]`;

val msg_regexp =
 Regexp_Type.fromQuote
   `\i{~90,90}\i{0,59}\i{0,5999}\i{~180,180}\i{0,59}\i{0,5999}\i{0,17999}(L|G|S)(T|F)`;

map Interval.interval_byte_width
    [ (~90,90), (0,59), (0,5999), (~180,180),(0,59),(0,5999),(0,17999)];

val msg_regexp_term = regexpSyntax.mk_regexp msg_regexp;

(*---------------------------------------------------------------------------*)
(* lift to level of msg format                                               *)
(*---------------------------------------------------------------------------*)

`!m:msg. good_msg m <=> toString(m) IN regexp_lang ^msg_regexp_term `;

*)
