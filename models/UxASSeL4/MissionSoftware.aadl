package MissionSoftware
public
	with TB_SYS;
	with SMACCM_DATA;
	with Base_Types;
   	with Data_Model;

	system top
	end top;

	system implementation top.i
		subcomponents
			software: process Mission_Software.i;
			soi_tk1: processor tk1_som.camkes;
		properties
			actual_processor_binding => (reference (soi_tk1)) applies to software;   
	end top.i;

	processor tk1_som
	end tk1_som;

	processor implementation tk1_som.camkes
	   properties
	      TB_SYS::OS => CAmkES;
	      TB_SYS::HW => TK1;
	      TB_SYS::Add_Dummy_Arg_To_Void_Fns => True;
	end tk1_som.camkes;

	process Mission_Software
	end Mission_Software;

	data mission_command
	end mission_command;

	data implementation mission_command.impl
  	properties
    	Data_Model::Data_Representation => Array;
    	Data_Model::Base_Type => (classifier (Base_Types::Unsigned_8));
    	-- The maximum size of a groomed mission command due to serialization 
    	-- in UxAS using two byte integers to represent the size of the waypoint 
    	-- list. 
    	-- Data_Model::Dimension => (5963744);
    	-- The maximum size if we restrict the size of waypoint lists to 255.
    	Data_Model::Dimension => (23264);
	end mission_command.impl;

	process implementation Mission_Software.i
		subcomponents
			clock_driver: thread Clock_Driver;
			uart_driver: thread UART_Driver;
			asset_waypoint_manager: thread Asset_Waypoint_Manager;
			waypoint_manager: thread Waypoint_Manager;
			virtual_machine: thread Virtual_Machine;
			mission : data mission_command.impl{
				--TODO this should be a subcomponent reference
				TB_SYS::CAmkES_Owner_Thread => "Virtual_Machine";
			};
			waypoint : data mission_command.impl{
				--TODO this should be a subcomponent reference
				TB_SYS::CAmkES_Owner_Thread => "Asset_Waypoint_Manager";
			};
			
			vm_waypoint : data mission_command.impl{
				--TODO this should be a subcomponent reference
				TB_SYS::CAmkES_Owner_Thread => "Asset_Waypoint_Manager";
			};
		connections
			wm2uart: port waypoint_manager.out_uart_packet -> uart_driver.in_uart_packet;
			uart2awm: port uart_driver.out_uart_packet -> asset_waypoint_manager.in_uart_packet;
			uart2wm: port uart_driver.out_send_success -> waypoint_manager.in_send_success;
			
			-- TODO: Give ports sensible names.
			
			e1: port virtual_machine.mission_write -> waypoint_manager.mission_write;
			e2: port waypoint_manager.mission_read -> virtual_machine.mission_read;
			e3: port virtual_machine.waypoint_read -> asset_waypoint_manager.waypoint_read_vm;
			e4: port waypoint_manager.waypoint_read -> asset_waypoint_manager.waypoint_read_wm;
			e5: port asset_waypoint_manager.waypoint_write_wm -> waypoint_manager.waypoint_write;
			e6: port asset_waypoint_manager.waypoint_write_vm -> virtual_machine.waypoint_write;
			
			uart_clkcar: subprogram group access uart_driver.clkcar -> clock_driver.clkcar;
			vm_clk_fwd: subprogram group access virtual_machine.clkcarfwd -> clock_driver.clkcarfwd;
			vm_uart_fwd: subprogram group access virtual_machine.uartfwd -> uart_driver.uartfwd;
			
			-- TODO: Give data access sensible names.
			d1: data access mission -> virtual_machine.mission;
			d2: data access mission -> waypoint_manager.mission;
			d3: data access waypoint -> waypoint_manager.waypoint;
			d5: data access waypoint -> asset_waypoint_manager.waypoint;
			d6: data access vm_waypoint -> virtual_machine.waypoint;
			d7: data access vm_waypoint -> asset_waypoint_manager.vm_waypoint;
			

			
			
	end Mission_Software.i;

	thread Clock_Driver
		features
			clkcar: provides subprogram group access clkcar_inf;
			clkcarfwd: provides subprogram group access gen_fwd_inf;
		properties
			TB_SYS::Is_External => true;
			Priority => 253;
			Dispatch_Protocol => Sporadic; 
			TB_SYS::Thread_Type => Active;
			Compute_Execution_Time => 10 us .. 100 us;
	end Clock_Driver;

	thread UART_Driver
		features
			out_uart_packet: out event data port SMACCM_DATA::UART_Packet.i;
			in_uart_packet: in event data port SMACCM_DATA::UART_Packet.i {
				-- Maximum possible size of mission command divided by 255.
				Queue_Size => 23388;
			};
			out_send_success: out event data port Base_Types::Boolean;
			
			uartfwd: provides subprogram group access gen_fwd_inf;
			clkcar: requires subprogram group access clkcar_inf;
		properties
			TB_SYS::Is_External => true;
			Priority => 250;
			Dispatch_Protocol => Sporadic;
			TB_SYS::Thread_Type => Active;
			Compute_Execution_Time => 10 us .. 100 us;
			TB_SYS::Sends_Events_To => "{{}}";
	end UART_Driver;
	
	subprogram group gen_fwd_inf
		properties
			TB_SYS::Is_External => true;
			TB_SYS::CommPrim_Source_Header => "gen_fwd.idl4";
	end gen_fwd_inf;
	
	subprogram group clkcar_inf
		properties
			TB_SYS::Is_External => true;
			TB_SYS::CommPrim_Source_Header => "clkcar.idl4";
	end clkcar_inf;

	thread Virtual_Machine
		features
			mission_write: out event data port Base_Types::Boolean {
				TB_SYS::CommPrim_Source_Text => "mission_write";
			};
			mission_read : in event data port Base_Types::Boolean {
				TB_SYS::Compute_Entrypoint_Source_Text => ("mission_read");
			};
			waypoint_write: in event data port Base_Types::Unsigned_32 {
				TB_SYS::Compute_Entrypoint_Source_Text => ("waypoint_write");
			};
			waypoint_read : out event data port Base_Types::Boolean {
				TB_SYS::CommPrim_Source_Text => "waypoint_read";
			};
			mission: requires data access mission_command.impl {
				Access_Right => READ_WRITE;
			};
			waypoint: requires data access mission_command.impl {
						Access_Right => READ_WRITE;
			};
			clkcarfwd: requires subprogram group access gen_fwd_inf;
			uartfwd: requires subprogram group access gen_fwd_inf;
		properties
			TB_SYS::Is_External => true;
			Priority => 100;
			Dispatch_Protocol => Sporadic;
			TB_SYS::Thread_Type => Active;
			Compute_Execution_Time => 10 us .. 100 us;
			TB_SYS::Sends_Events_To => "{{}}";
	end Virtual_Machine;
	
	thread Waypoint_Manager
		features
			mission_read : out event data port Base_Types::Boolean {
				TB_SYS::CommPrim_Source_Text => "mission_read";
			};
			mission_write : in event data port Base_Types::Boolean {
				TB_SYS::Compute_Entrypoint_Source_Text => ("mission_write");
			};
			waypoint_read : out event data port Base_Types::Boolean {
				TB_SYS::CommPrim_Source_Text => "waypoint_read";
			};
			waypoint_write : in event data port Base_Types::Unsigned_32 {
				TB_SYS::Compute_Entrypoint_Source_Text => ("waypoint_write");				
			};
			mission: requires data access mission_command.impl {
				Access_Right => READ_WRITE;
			};
			waypoint: requires data access mission_command.impl {
				Access_Right => READ_WRITE;
			};
					
			in_send_success: in event data port Base_Types::Boolean{
				TB_SYS::Compute_Entrypoint_Source_Text => ("in_send_success");
			};
			out_uart_packet: out event data port SMACCM_DATA::UART_Packet.i {
				TB_SYS::CommPrim_Source_Text => "out_uart_packet";
			};
		properties
			Source_Text => ("mcutils/mcutils.c", "mcutils/mcutils.h");
			Dispatch_Protocol => Periodic;
			TB_SYS::Thread_Type => Active;
			Priority => 150;
			Stack_Size => 1024 Bytes; 
			Compute_Execution_Time => 10 us .. 100 us;
			TB_SYS::Sends_Events_To => "{{}}";
			TB_SYS::Compute_Entrypoint_Source_Text => ("component_entry");
			Initialize_Entrypoint_Source_Text => "component_init";
			Period => 25 ms;
	end Waypoint_Manager;
	
	thread Asset_Waypoint_Manager
		features
			waypoint_write_wm: out event data port Base_Types::Unsigned_32 {
				TB_SYS::CommPrim_Source_Text => "waypoint_write_wm";
			};
			waypoint_write_vm: out event data port Base_Types::Unsigned_32 {
				TB_SYS::CommPrim_Source_Text => "waypoint_write_vm";
			};
			waypoint_read_vm: in event data port Base_Types::Boolean {
				TB_SYS::Compute_Entrypoint_Source_Text => ("mission_read_vm");
			};
			waypoint_read_wm: in event data port Base_Types::Boolean {
				TB_SYS::Compute_Entrypoint_Source_Text => ("mission_read_wm");
			};
			waypoint: requires data access mission_command.impl {
						Access_Right => READ_WRITE;
					};
			vm_waypoint: requires data access mission_command.impl {
						Access_Right => READ_WRITE;
					};
					
			in_uart_packet: in event data port SMACCM_DATA::UART_Packet.i{
				TB_SYS::Compute_Entrypoint_Source_Text => ("in_uart_packet");
				-- Maximum possible size of mission command divided by 255.
				Queue_Size => 23388;
			};
		properties
			Source_Text => ("mcutils/mcutils.c", "mcutils/mcutils.h");
	        Dispatch_Protocol => Periodic;
		    Period => 25 ms;
	   		Priority => 151;
	    	Stack_Size => 256 bytes;
	    	TB_SYS::Thread_Type => Active ;
	    	Compute_Execution_Time => 10 us .. 50 us;
	    	TB_SYS::Sends_Events_To => "{{}}";
		    TB_SYS::Compute_Entrypoint_Source_Text => ("component_entry");
			Initialize_Entrypoint_Source_Text => "component_init";
	end Asset_Waypoint_Manager;
	
end MissionSoftware;

